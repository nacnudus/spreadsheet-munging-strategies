[
["index.html", "Spreadsheet Munging Strategies Welcome", " Spreadsheet Munging Strategies Duncan Garmonsway Welcome This is a work-in-progress book about getting data out of spreadsheets, no matter how peculiar. The book is designed primarily for R users who have to extract data from spreadsheets and who are already familiar with the tidyverse. It has a cookbook structure, and can be used as a reference, but readers who begin in the middle might have to work backwards from time to time. R packages that feature heavily are unpivotr: deals with non-tabular data, especially from spreadsheets. tidyxl: imports non-tabular data from Excel files Tidyxl and unpivotr are much more complicated than readxl, and that’s the point. Tidyxl and unpivotr give you more power and complexity when you need it. Please help me to improve this book by opening a GitHub issue or tweeting. Creative Commons License The online version of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["setup.html", "1 Setup", " 1 Setup This section describes how the code in the book is set up. "],
["packages.html", "1.1 Packages", " 1.1 Packages Here are the packages used by the code in this book. The last three are my own: tidyxl, unpivotr and smungs. You will need to install the latest versions from CRAN or GitHub. library(tibble) library(tidyr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(purrr) library(stringr) library(readr) library(readxl) library(tidyxl) library(unpivotr) library(smungs) # GitHub only https://github.com/nacnudus/smungs "],
["data.html", "1.2 Data", " 1.2 Data The examples draw from a spreadsheet of toy data, included in the unpivotr package. It is recommended to download the spreadsheet and have open it in a spreadsheet application while you read the book. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) "],
["tidyish.html", "2 Tidy-ish tables", " 2 Tidy-ish tables This chapter is a gentle introduction, by taking what you already know about importing tidy tabular data (with read.csv() or the readr package), and shows you how to how to do the same things with tidyxl and unpivotr. It works up to tables that are mostly tidy, but have subtle problems. "],
["tidy-clean.html", "2.1 Clean &amp; tidy tables", " 2.1 Clean &amp; tidy tables If the tables in the spreadsheet are clean and tidy, then you should use a package like readxl. But it’s worth knowing how to emulate readxl with tidyxl and unpivotr, because some almost clean tables can be handled using these techniques. Clean and tidy means One table per sheet A single row of column headers, or no headers A single data type in each column Only one kind of sentinel value (to be interpreted as NA) No meaningful formatting No data buried in formulas No need to refer to named ranges Here’s the full process. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(row, data_type, header, character, numeric) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 3 x 2 ## Age Name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Matilda ## 2 3 Nicholas ## 3 5 Olivia tidyxl::xlsx_cells() imports the spreadsheet into a data frame, where each row of the data frame describes one cell of the spreadsheet. The columns row and col (and address) describe the position of the cell, and the value of the cell is in one of the columns error, logical, numeric, date, character, depending on the type of data in the cell. The column data_type says which column the value is in. Other columns describe formatting and formulas. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% select(row, col, data_type, character, numeric) ## # A tibble: 8 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 1 character Name NA ## 2 1 2 character Age NA ## 3 2 1 character Matilda NA ## 4 2 2 numeric &lt;NA&gt; 1 ## 5 3 1 character Nicholas NA ## 6 3 2 numeric &lt;NA&gt; 3 ## 7 4 1 character Olivia NA ## 8 4 2 numeric &lt;NA&gt; 5 unpivotr::behead() takes one level of headers from a pivot table and makes it part of the data. Think of it like tidyr::gather(), except that it works when there is more than one row of headers (or more than one column of row-headers), and it only works on tables that have first come through unpivotr::as_cells() or tidyxl::xlsx_cells(). xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% select(row, col, data_type, character, numeric) %&gt;% behead(&quot;N&quot;, header) ## # A tibble: 6 x 6 ## row col data_type character numeric header ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 1 character Matilda NA Name ## 2 2 2 numeric &lt;NA&gt; 1 Age ## 3 3 1 character Nicholas NA Name ## 4 3 2 numeric &lt;NA&gt; 3 Age ## 5 4 1 character Olivia NA Name ## 6 4 2 numeric &lt;NA&gt; 5 Age unpivotr::spatter() spreads key-value pairs across multiple columns, like tidyxl::spread(), except that it handles mixed data types. It knows which column contains the cell value (i.e. the character column or the numeric column), by checking the data_type column. Just like tidyr::spread(), it can be confused by extraneous data, so it’s usually a good idea to drop the col column first, and to keep the row column. xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% select(row, col, data_type, character, numeric) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 3 x 2 ## Age Name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Matilda ## 2 3 Nicholas ## 3 5 Olivia In case the table has no column headers, you can spatter the col column instead of a nonexistent header column. xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% dplyr::filter(row &gt;= 2) %&gt;% select(row, col, data_type, character, numeric) %&gt;% spatter(col) %&gt;% select(-row) ## # A tibble: 3 x 2 ## `1` `2` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 Tidyxl and unpivotr are much more complicated than readxl, and that’s the point: tidyxl and unpivotr give you more power and complexity when you need it. read_excel(path, sheet = &quot;clean&quot;) ## # A tibble: 3 x 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 read_excel(path, sheet = &quot;clean&quot;, col_names = FALSE, skip = 1) ## # A tibble: 3 x 2 ## X__1 X__2 ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 "],
["almost-tidy-tables.html", "2.2 Almost-tidy tables", " 2.2 Almost-tidy tables For tables that are already ‘tidy’ (a single row of column headers), use packages like readxl that specialise in importing tidy data. For everything else, read on. 2.2.1 Transposed (headers in the first row, data extends to the right) Most packages for importing data assume that the headers are in the first row, and each row of data is an observation. They usually don’t support the alternative: headers in the first column, and each column of data is an observation. You can hack a way around this by importing without recognising any headers, transposing with t() (which outputs a matrix), placing the headers as names, and converting back to a data frame, but this almost always results in all the data types being converted. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) read_excel(path, sheet = &quot;transposed&quot;, col_names = FALSE) %&gt;% t() %&gt;% `colnames&lt;-`(.[1, ]) %&gt;% .[-1, ] %&gt;% as_tibble() ## # A tibble: 3 x 2 ## Name Age ## &lt;chr&gt; &lt;chr&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 Tidyxl and unpivotr are agnostic to the layout of tables. Importing the transpose is the same is importing the usual layout, merely using the &quot;W&quot; (west) direction instead of &quot;N&quot; (north) when beheading the headers. xlsx_cells(path, sheet = &quot;transposed&quot;) %&gt;% behead(&quot;W&quot;, header) %&gt;% select(col, data_type, header, character, numeric) %&gt;% spatter(header) %&gt;% select(Name, Age) ## # A tibble: 3 x 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 2.2.2 Other stuff on the same sheet It will be more complicated when the table doesn’t begin in cell A1, or if there are non-blank cells above, below or either side of the table. If you know at coding time which rows and columns the table occupies, then you can do the following. Blank or non-blank cells above the table: use the skip argument of readxl::read_excel(). Blank or non-blank cells either side of the table: use the col_types argument of readxl::read_excel() to ignore those columns. Blank or non-blank cells below the table: use n_max argument of readxl::read_excel() to ignore those rows. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) readxl::read_excel(path, sheet = &quot;notes&quot;, skip = 2, n_max = 33, col_types = c(&quot;guess&quot;, &quot;guess&quot;, &quot;skip&quot;)) %&gt;% drop_na() ## # A tibble: 2 x 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 If you don’t know at coding time which rows and columns the table occupies ( e.g. when the latest version of the spreadsheet is published and the table has moved), then one strategy is to read the spreadsheet with tidyxl::xlsx_cells() first, and inspect the results to determine the boundaries of the table. Then use those boundaries as the skip, n_max and col_types arguments to readxl::read_excel() Read the spreadsheet with tidyxl::xlsx_cells(). Filter the result for sentinel values, e.g. the cells containing the first and final column headers, and a cell in the final row of data. Construct the arguments skip, n_max and col_types so that readxl::read_excel() gets the exact dimensions of the table. # Step 1: read the spreadsheet and filter for sentinel values to detect the # top-left and bottom-right cells cells &lt;- xlsx_cells(path, sheet = &quot;notes&quot;) rectify(cells) ## # A tibble: 7 x 5 ## `row/col` `1(A)` `2(B)` `3(C)` `4(D)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Title text &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 3 &lt;NA&gt; Name Age &lt;NA&gt; ## 4 4 &lt;NA&gt; Matilda 1 &lt;NA&gt; ## 5 5 &lt;NA&gt; Nicholas 3 &lt;NA&gt; ## 6 6 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 7 7 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Footnote top_left &lt;- dplyr::filter(cells, character == &quot;Name&quot;) %&gt;% select(row, col) top_left ## # A tibble: 1 x 2 ## row col ## &lt;int&gt; &lt;int&gt; ## 1 3 2 # It can be tricky to find the bottom-right cell because you have to make some # assumptions. Here we assume that only cells within the table are numeric. bottom_right &lt;- dplyr::filter(cells, data_type == &quot;numeric&quot;) %&gt;% summarise(row = max(row), col = max(col)) bottom_right ## # A tibble: 1 x 2 ## row col ## &lt;dbl&gt; &lt;dbl&gt; ## 1 5 3 # Step 2: construct the arguments `skip` and `n_max` for read_excel() skip &lt;- top_left$row - 1L n_rows &lt;- bottom_right$row - skip read_excel(path, sheet = &quot;notes&quot;, skip = skip, n_max = n_rows) ## # A tibble: 2 x 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 Here’s another way using only tidyxl and unpivotr. # Step 2: filter for cells between the top-left and bottom-right, and spatter # into a table cells %&gt;% dplyr::filter(between(row, top_left$row, bottom_right$row), between(col, top_left$col, bottom_right$col)) %&gt;% select(row, col, data_type, character, numeric) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 2 x 2 ## Age Name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Matilda ## 2 3 Nicholas "],
["tidy-formatted-rows.html", "2.3 Meaningfully formatted rows", " 2.3 Meaningfully formatted rows As with clean, tidy tables, but with a second step to interpret the formatting. Sometimes whole rows in a table are highlighted by formatting them with, say, a bright yellow fill. The highlighting could mean “this observation should be ignored”, or “this product is no longer available”. Different colours could mean different levels of a hierarchy, e.g. green for “pass” and red for “fail”. There are three steps to interpreting this. Import the table, taking only the cell values and ignoring the formatting. Import one column of the table, taking only the formatting and not the cell values. Use dplyr::bind_cols() to append the column of formatting to the table of cell values. You can then interpret the formatting however you like. Step 1 is the same as clean, tidy tables. Step 2 uses tidyxl::xlsx_cells() to load the data, tidyxl::xlsx_formats(), and several tidyverse functions to link the two and filter for only one column. Why only one column? Because if a whole row is highlighted, then you only need to know the highlighting of one column to know the highlighting of all the others. This is a special case of the following section, meaningfully formatted cells. Here dplyr::bind_cols() can be used as a shortcut, because we are joining exactly n rows of formatting to n rows of data. The following sections is a more general case that can be used instead of this procedure. # Step 1: import the table taking only cell values and ignoring the formatting path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) x &lt;- read_excel(path, sheet = &quot;highlights&quot;) # Step 2: import one column of the table, taking only the formatting and not the # cell values # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb # Import all the cells, filter out the header row, filter for the first column, # and create a new column `fill_colour` of the fill colours, by looking up the # local_format_id of each cell in the `fill_colours` pallette. fills &lt;- xlsx_cells(path, sheet = &quot;highlights&quot;) %&gt;% dplyr::filter(row &gt;= 2, col == 1) %&gt;% # Omit the header row mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(fill_colour) # Step 3: append the `fill` column to the rest of the data bind_cols(x, fills) %&gt;% select(Age, Height, fill_colour) ## # A tibble: 3 x 3 ## Age Height fill_colour ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 2 &lt;NA&gt; ## 2 3 4 FFFFFF00 ## 3 5 6 &lt;NA&gt; Note that the fill colour is expressed as an RGB value with transparency in the first two letters, e.g. FFFFFF00 is FF (opaque), with FFFF00 (yellow). Here’s another way using only tidyxl and unpivotr. fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb xlsx_cells(path, sheet = &quot;highlights&quot;) %&gt;% mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, data_type, character, numeric, fill_colour) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col, -character) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 3 x 3 ## fill_colour Age Height ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &lt;NA&gt; 1 2 ## 2 FFFFFF00 3 4 ## 3 &lt;NA&gt; 5 6 "],
["tidy-formatted-cells.html", "2.4 Meaningfully formatted cells", " 2.4 Meaningfully formatted cells If single cells are highlighted, rather than whole rows, then the highlights probably indicate something about the column rather than the row. For example, a highlighted cell in a column called “age” of a table of medical patients, might mean “the age of this patient is uncertain”. One way to deal with this is to create a new column in the final table for each column in the original that has any highlighted cells. For example, if highlighted cells mean “this value is uncertain”, and some cells in the age and height columns are highlighted, then you could create two new columns: uncertain_age, and uncertain_height, by following the procedure of meaningfully formatted rows for each column age and height. # Step 1: import the table taking only cell values and ignoring the formatting path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) x &lt;- read_excel(path, sheet = &quot;annotations&quot;) # Step 2: import one column of the table, taking only the formatting and not the # cell values # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb # Import all the cells, filter out the header row, filter for the first column, # and create new columns `something_fill` of the fill colours, by looking up the # local_format_id of each cell in the `formats` pallette. fills &lt;- xlsx_cells(path, sheet = &quot;annotations&quot;) %&gt;% dplyr::filter(row &gt;= 2, col &gt;= 2) %&gt;% # Omit the header row and name column mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, fill_colour) %&gt;% spread(col, fill_colour) %&gt;% select(-row) %&gt;% set_names(paste0(colnames(x)[-1], &quot;_fill&quot;)) fills ## # A tibble: 3 x 2 ## Age_fill Height_fill ## &lt;chr&gt; &lt;chr&gt; ## 1 &lt;NA&gt; &lt;NA&gt; ## 2 FFFFFF00 &lt;NA&gt; ## 3 &lt;NA&gt; FF92D050 # Step 3: append the `fill` column to the rest of the data bind_cols(x, fills) ## # A tibble: 3 x 5 ## Name Age Height Age_fill Height_fill ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Matilda 1 2 &lt;NA&gt; &lt;NA&gt; ## 2 Nicholas 3 4 FFFFFF00 &lt;NA&gt; ## 3 Olivia 5 6 &lt;NA&gt; FF92D050 Here’s the same thing, but using only tidyxl and unpivotr fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb cells &lt;- xlsx_cells(path, sheet = &quot;annotations&quot;) %&gt;% mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, data_type, character, numeric, fill_colour) cells ## # A tibble: 12 x 6 ## row col data_type character numeric fill_colour ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 1 character Name NA &lt;NA&gt; ## 2 1 2 character Age NA &lt;NA&gt; ## 3 1 3 character Height NA &lt;NA&gt; ## 4 2 1 character Matilda NA &lt;NA&gt; ## 5 2 2 numeric &lt;NA&gt; 1 &lt;NA&gt; ## 6 2 3 numeric &lt;NA&gt; 2 &lt;NA&gt; ## 7 3 1 character Nicholas NA &lt;NA&gt; ## 8 3 2 numeric &lt;NA&gt; 3 FFFFFF00 ## 9 3 3 numeric &lt;NA&gt; 4 &lt;NA&gt; ## 10 4 1 character Olivia NA &lt;NA&gt; ## 11 4 2 numeric &lt;NA&gt; 5 &lt;NA&gt; ## 12 4 3 numeric &lt;NA&gt; 6 FF92D050 values &lt;- cells %&gt;% select(-fill_colour) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) values ## # A tibble: 3 x 4 ## row Age Height Name ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 1 2 Matilda ## 2 3 3 4 Nicholas ## 3 4 5 6 Olivia fills &lt;- cells %&gt;% behead(&quot;N&quot;, header) %&gt;% mutate(header = paste0(header, &quot;_fill&quot;)) %&gt;% select(row, header, fill_colour) %&gt;% spread(header, fill_colour) fills ## # A tibble: 3 x 4 ## row Age_fill Height_fill Name_fill ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 3 FFFFFF00 &lt;NA&gt; &lt;NA&gt; ## 3 4 &lt;NA&gt; FF92D050 &lt;NA&gt; left_join(values, fills, by = &quot;row&quot;) %&gt;% select(-row) ## # A tibble: 3 x 6 ## Age Height Name Age_fill Height_fill Name_fill ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 2 Matilda &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 3 4 Nicholas FFFFFF00 &lt;NA&gt; &lt;NA&gt; ## 3 5 6 Olivia &lt;NA&gt; FF92D050 &lt;NA&gt; Another way would be to make the table what I call “extra-tidy”. If it is tidy, then each row is an observation, and each column is a variable. To make it “extra-tidy”, you gather() the variables so that each row is one observation of one variable. This works best when every variable has the same data type, otherwise the values will be coerced, probably to a character. # Tidy (x &lt;- read_excel(path, sheet = &quot;annotations&quot;)) ## # A tibble: 3 x 3 ## Name Age Height ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Matilda 1 2 ## 2 Nicholas 3 4 ## 3 Olivia 5 6 # Extra-tidy extra_tidy &lt;- x %&gt;% gather(variable, value, -Name) %&gt;% arrange(Name, variable) extra_tidy ## # A tibble: 6 x 3 ## Name variable value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda Age 1 ## 2 Matilda Height 2 ## 3 Nicholas Age 3 ## 4 Nicholas Height 4 ## 5 Olivia Age 5 ## 6 Olivia Height 6 With an extra-tidy dataset, the formatting can now be appended to the values of individual variables, rather than to whole observations. # Extra-tidy, with row and column numbers of the original variables extra_tidy &lt;- read_excel(path, sheet = &quot;annotations&quot;) %&gt;% mutate(row = row_number() + 1L) %&gt;% gather(variable, value, -row, -Name) %&gt;% group_by(row) %&gt;% mutate(col = row_number() + 1L) %&gt;% ungroup() %&gt;% select(row, col, Name, variable, value) %&gt;% arrange(row, col) extra_tidy ## # A tibble: 6 x 5 ## row col Name variable value ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 2 Matilda Age 1 ## 2 2 3 Matilda Height 2 ## 3 3 2 Nicholas Age 3 ## 4 3 3 Nicholas Height 4 ## 5 4 2 Olivia Age 5 ## 6 4 3 Olivia Height 6 # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb # Import all the cells, filter out the header row, filter for the first column, # and create a new column `uncertain` based on the fill colours, by looking up # the local_format_id of each cell in the `formats` pallette. fills &lt;- xlsx_cells(path, sheet = &quot;annotations&quot;) %&gt;% dplyr::filter(row &gt;= 2, col &gt;= 2) %&gt;% # Omit the header row and name column mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, fill_colour) fills ## # A tibble: 6 x 3 ## row col fill_colour ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 2 &lt;NA&gt; ## 2 2 3 &lt;NA&gt; ## 3 3 2 FFFFFF00 ## 4 3 3 &lt;NA&gt; ## 5 4 2 &lt;NA&gt; ## 6 4 3 FF92D050 # Step 3: append the `fill` column to the rest of the data left_join(extra_tidy, fills, by = c(&quot;row&quot;, &quot;col&quot;)) ## # A tibble: 6 x 6 ## row col Name variable value fill_colour ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 2 Matilda Age 1 &lt;NA&gt; ## 2 2 3 Matilda Height 2 &lt;NA&gt; ## 3 3 2 Nicholas Age 3 FFFFFF00 ## 4 3 3 Nicholas Height 4 &lt;NA&gt; ## 5 4 2 Olivia Age 5 &lt;NA&gt; ## 6 4 3 Olivia Height 6 FF92D050 Here’s the same extra-tidy version, but using only tidyxl and unpivotr. fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb xlsx_cells(path, sheet = &quot;annotations&quot;) %&gt;% mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, data_type, character, numeric, fill_colour) %&gt;% behead(&quot;W&quot;, Name) %&gt;% behead(&quot;N&quot;, variable) %&gt;% select(-data_type, -character, value = numeric) ## # A tibble: 6 x 6 ## row col value fill_colour Name variable ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 2 1 &lt;NA&gt; Matilda Age ## 2 2 3 2 &lt;NA&gt; Matilda Height ## 3 3 2 3 FFFFFF00 Nicholas Age ## 4 3 3 4 &lt;NA&gt; Nicholas Height ## 5 4 2 5 &lt;NA&gt; Olivia Age ## 6 4 3 6 FF92D050 Olivia Height "],
["layered-formatting.html", "2.5 Layered meaningful formatting", " 2.5 Layered meaningful formatting Sometimes different kinds of formatting relate to clearly different aspects of an observation, e.g. yellow highlight for “uncertain data” and red text for “product no longer available”. Both yellow highlighting and red text in the same row would indicate uncertain data and unavailability of the product at the same time. Deal with it by reading each kind of formatting into a separate column, e.g. fill colour into one column, font colour into another, bold/not-bold into a another, etc. # Step 1: import the table taking only cell values and ignoring the formatting path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) x &lt;- read_excel(path, sheet = &quot;combined-highlights&quot;) # Step 2: import one kind of formatting of one column of the table # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb font_colours &lt;- xlsx_formats(path)$local$font$color$rgb # Import all the cells, filter out the header row, filter for the first column, # and create a new column `fill` of the fill colours, by looking up the # local_format_id of each cell in the `formats` pallette. formats &lt;- xlsx_cells(path, sheet = &quot;combined-highlights&quot;) %&gt;% dplyr::filter(row &gt;= 2, col == 1) %&gt;% # Omit the header row mutate(fill_colour = fill_colours[local_format_id], font_colour = font_colours[local_format_id]) %&gt;% select(fill_colour, font_colour) # Step 3: append the `fill` column to the rest of the data bind_cols(x, formats) ## # A tibble: 4 x 5 ## Name Weight Price fill_colour font_colour ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Knife 7 8 &lt;NA&gt; FF000000 ## 2 Fork 5 6 FFFFFF00 FF000000 ## 3 Spoon 3 4 &lt;NA&gt; FFFF0000 ## 4 Teaspoon 1 2 FFFFFF00 FFFF0000 Here’s the same thing, but using only tidyxl and unpivotr. fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb font_colours &lt;- xlsx_formats(path)$local$font$color$rgb cells &lt;- xlsx_cells(path, sheet = &quot;combined-highlights&quot;) %&gt;% mutate(fill_colour = fill_colours[local_format_id], font_colour = font_colours[local_format_id]) %&gt;% select(row, col, data_type, character, numeric, fill_colour, font_colour) %&gt;% behead(&quot;N&quot;, header) %&gt;% behead(&quot;W&quot;, Name) %&gt;% select(-col, -character) values &lt;- cells %&gt;% select(-fill_colour, -font_colour) %&gt;% spread(header, numeric) formats &lt;- distinct(cells, row, fill_colour, font_colour) left_join(values, formats, by = &quot;row&quot;) %&gt;% select(-row) ## # A tibble: 4 x 6 ## data_type Name Price Weight fill_colour font_colour ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 numeric Knife 8 7 &lt;NA&gt; FF000000 ## 2 numeric Fork 6 5 FFFFFF00 &lt;NA&gt; ## 3 numeric Spoon 4 3 &lt;NA&gt; FFFF0000 ## 4 numeric Teaspoon 2 1 FFFFFF00 FFFF0000 "],
["hierarchies-in-formatting.html", "2.6 Hierarchies in formatting", " 2.6 Hierarchies in formatting Different kinds of formatting might also represent different levels of a hierarchy, e.g. formatting interpretation none good italic satisfactory bold poor bold &amp; italic fail When each kind of formatting relates to a different level of one hierarchy, import the different kinds of formatting into different columns, and then combine them into a third column, perhaps using paste(), or case_when(). # Step 1: import the table taking only cell values and ignoring the formatting x &lt;- read_excel(path, sheet = &quot;highlight-hierarchy&quot;) x ## # A tibble: 4 x 2 ## Name Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 7 ## 2 Nicholas 5 ## 3 Olivia 3 ## 4 Paul 1 # Step 2: import one kind of formatting of one column of the table # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell bold &lt;- xlsx_formats(path)$local$font$bold italic &lt;- xlsx_formats(path)$local$font$italic # Import all the cells, filter out the header row, filter for the first column, # and create a new column `fill` of the fill colours, by looking up the # local_format_id of each cell in the `formats` pallette. formats &lt;- xlsx_cells(path, sheet = &quot;highlight-hierarchy&quot;) %&gt;% dplyr::filter(row &gt;= 2, col == 1) %&gt;% # Omit the header row mutate(bold = bold[local_format_id], italic = italic[local_format_id]) %&gt;% mutate(grade = case_when(bold &amp; italic ~ &quot;fail&quot;, bold ~ &quot;poor&quot;, italic ~ &quot;satisfactory&quot;, TRUE ~ &quot;good&quot;)) %&gt;% select(bold, italic, grade) # Step 3: append the `fill` column to the rest of the data bind_cols(x, formats) ## # A tibble: 4 x 5 ## Name Score bold italic grade ## &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; ## 1 Matilda 7 FALSE FALSE good ## 2 Nicholas 5 FALSE TRUE satisfactory ## 3 Olivia 3 TRUE FALSE poor ## 4 Paul 1 TRUE TRUE fail Here it is again, using only tidyxl and unpivotr. bold &lt;- xlsx_formats(path)$local$font$bold italic &lt;- xlsx_formats(path)$local$font$italic xlsx_cells(path, sheet = &quot;highlight-hierarchy&quot;) %&gt;% mutate(bold = bold[local_format_id], italic = italic[local_format_id]) %&gt;% mutate(grade = case_when(bold &amp; italic ~ &quot;fail&quot;, bold ~ &quot;poor&quot;, italic ~ &quot;satisfactory&quot;, TRUE ~ &quot;good&quot;)) %&gt;% select(row, col, data_type, character, numeric, bold, italic, grade) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) ## # A tibble: 4 x 6 ## row bold italic grade Name Score ## &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 FALSE FALSE good Matilda 7 ## 2 3 FALSE TRUE satisfactory Nicholas 5 ## 3 4 TRUE FALSE poor Olivia 3 ## 4 5 TRUE TRUE fail Paul 1 "],
["tidy-sentinel.html", "2.7 Sentinel values in non-text columns", " 2.7 Sentinel values in non-text columns R packages like readr recognise NA as a sentinel value that means “Not Applicable”, or “Not Available”, or anything you want. It doesn’t affect the data type of a column when NA is one of the values. Some datasets use other symbols as a sentinel value, e.g. N/A or ., or a combination, in which case you can instruct readr to interpret those values as sentinels, and it will import them all as NA. But what if the data uses more than one kind of sentinel value. For example, Statistics New Zealand uses … to mean “Not applicable”, and ..C to mean “Confidentialised”. Most tools will either regard both values as NA, or coerce the whole column to characters. read_csv(&quot;a, b, c 1, 2, 3 4, …, ..C&quot;, na = c(&quot;…&quot;, &quot;..C&quot;)) # Regard both values as NA ## # A tibble: 2 x 3 ## a b c ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 ## 2 4 NA NA read_csv(&quot;a, b, c 1, 2, 3 4, …, ..C&quot;, na = &quot;&quot;) # Coerce the whole column to characters ## # A tibble: 2 x 3 ## a b c ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 2 3 ## 2 4 … ..C A better procedure is to import the sentinel values into their own column, or even into separate TRUE/FALSE columns for each kind of sentinel. Note that sentinel values relate the the value in the cell, rather than to the whole row, so the first step is to make the dataset extra-tidy as in the section “Already a tidy table but with meaningful formatting of single cells”. # Tidy path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) x &lt;- read_excel(path, sheet = &quot;sentinels&quot;) x ## # A tibble: 4 x 3 ## Name Subject Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Matilda Music 7 ## 2 Nicholas Classics NA ## 3 Olivia … 3 ## 4 Paul NA ..C # Extra-tidy extra_tidy &lt;- gather(x, variable, value, -Name) %&gt;% arrange(Name, variable) extra_tidy ## # A tibble: 8 x 3 ## Name variable value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Matilda Score 7 ## 2 Matilda Subject Music ## 3 Nicholas Score NA ## 4 Nicholas Subject Classics ## 5 Olivia Score 3 ## 6 Olivia Subject … ## 7 Paul Score ..C ## 8 Paul Subject NA With an extra-tidy dataset, the sentinels can now be appended to the values of individual variables, rather than to whole observations. # Extra-tidy, with row and column numbers of the original variables, and the # sentinels omitted extra_tidy &lt;- read_excel(path, sheet = &quot;sentinels&quot;, na = c(&quot;NA&quot;, &quot;…&quot;, &quot;..C&quot;)) %&gt;% mutate(row = row_number() + 1L) %&gt;% gather(variable, value, -row, -Name) %&gt;% group_by(row) %&gt;% mutate(col = row_number() + 1L) %&gt;% ungroup() %&gt;% select(row, col, Name, variable, value) %&gt;% arrange(row, col) extra_tidy ## # A tibble: 8 x 5 ## row col Name variable value ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 2 Matilda Subject Music ## 2 2 3 Matilda Score 7 ## 3 3 2 Nicholas Subject Classics ## 4 3 3 Nicholas Score &lt;NA&gt; ## 5 4 2 Olivia Subject &lt;NA&gt; ## 6 4 3 Olivia Score 3 ## 7 5 2 Paul Subject &lt;NA&gt; ## 8 5 3 Paul Score &lt;NA&gt; # Import all the cells, and filter for sentinel values sentinels &lt;- xlsx_cells(path, sheet = &quot;sentinels&quot;) %&gt;% dplyr::filter(character %in% c(&quot;NA&quot;, &quot;…&quot;, &quot;..C&quot;)) %&gt;% mutate(sentinel = character) %&gt;% select(row, col, sentinel) sentinels ## # A tibble: 4 x 3 ## row col sentinel ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 3 NA ## 2 4 2 … ## 3 5 2 NA ## 4 5 3 ..C # Join the `sentinel` column to the rest of the data left_join(extra_tidy, sentinels, by = c(&quot;row&quot;, &quot;col&quot;)) ## # A tibble: 8 x 6 ## row col Name variable value sentinel ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 2 Matilda Subject Music &lt;NA&gt; ## 2 2 3 Matilda Score 7 &lt;NA&gt; ## 3 3 2 Nicholas Subject Classics &lt;NA&gt; ## 4 3 3 Nicholas Score &lt;NA&gt; NA ## 5 4 2 Olivia Subject &lt;NA&gt; … ## 6 4 3 Olivia Score 3 &lt;NA&gt; ## 7 5 2 Paul Subject &lt;NA&gt; NA ## 8 5 3 Paul Score &lt;NA&gt; ..C Here’s another version using only tidyxl and unpivotr, which provides isolate_sentinels() to make this much more straightforward. xlsx_cells(path, sheet = &quot;sentinels&quot;) %&gt;% select(row, col, data_type, character, numeric) %&gt;% isolate_sentinels(character, c(&quot;NA&quot;, &quot;…&quot;, &quot;..C&quot;)) %&gt;% behead(&quot;W&quot;, Name) %&gt;% behead(&quot;N&quot;, variable) %&gt;% select(Name, variable, character, numeric, sentinel) ## # A tibble: 8 x 5 ## Name variable character numeric sentinel ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Matilda Subject Music NA &lt;NA&gt; ## 2 Matilda Score &lt;NA&gt; 7 &lt;NA&gt; ## 3 Nicholas Subject Classics NA &lt;NA&gt; ## 4 Nicholas Score &lt;NA&gt; NA NA ## 5 Olivia Subject &lt;NA&gt; NA … ## 6 Olivia Score &lt;NA&gt; 3 &lt;NA&gt; ## 7 Paul Subject &lt;NA&gt; NA NA ## 8 Paul Score &lt;NA&gt; NA ..C "],
["pivot.html", "3 Pivot tables", " 3 Pivot tables This part introduces pivot tables. Tidyxl and unpivotr come into their own here, and are (as far as I know) the only the only packages to acknowledge the intuitive grammar of pivot tables. Pivot tables are ones with more than one row of column headers, or more than one column of row headers, or both (and there can be more complex arrangements). Tables in that form take up less space on a page or a screen than ‘tidy’ tables, and are easier for humans to read. But most software can’t interpret or traverse data in that form; it must first be reshaped into a long, ‘tidy’ form, with a single row of column headers. It takes a lot of code to reshape a pivot table into a ‘tidy’ one, and the code has to be bespoke for each table. There’s no general solution, because it is ambiguous whether a given cell is part of a header or part of the data. There are some ambiguities in ‘tidy’ tables, too, which is why most functions for reading csv files allow you to specify whether the first row of the data is a header, and how many rows to skip before the data begins. Functions often guess, but they can never be certain. Pivot tables, being more complex, are so much more ambiguous that it isn’t reasonable to import them with a single function. A better way is to break the problem down into steps: Identify which cells are headers, and which are data. State how the data cells relate to the header cells. The first step is a matter of traversing the cells, which is much easier if you load them with the tidyxl package, or pass the table through as_cells() in the unpivotr package. This gives you a table of cells and their properties; one row of the table describes one cell of the source table or spreadsheet. The first two properties are the row and column position of the cell, which makes it easy to filter for cells in a particular region of the spreadsheet. If the first row of cells is a header row, then you can filter for row == 1. Here is an example of a pivot table where the first two rows, and the first two columns, are headers. The other cells contain the data. First, see how the cells are laid out in the source file by importing it with readxl. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) original &lt;- read_excel(path, sheet = &quot;pivot-annotations&quot;, col_names = FALSE) print(original, n = Inf) ## # A tibble: 6 x 6 ## X__1 X__2 X__3 X__4 X__5 X__6 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &lt;NA&gt; &lt;NA&gt; Female &lt;NA&gt; Male &lt;NA&gt; ## 2 &lt;NA&gt; &lt;NA&gt; Matilda Olivia Nicholas Paul ## 3 Humanities Classics 1 2 3 0 ## 4 &lt;NA&gt; History 3 4 5 1 ## 5 Performance Music 5 6 9 2 ## 6 &lt;NA&gt; Drama 7 8 12 3 Compare that with the long set of cells, one per row, that tidyxl gives. (Only a few properties of each cell are shown, to make it easier to read). cells &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) select(cells, row, col, data_type, character, numeric) %&gt;% print(cells, n = 20) ## # A tibble: 32 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 character Female NA ## 2 2 5 blank &lt;NA&gt; NA ## 3 2 6 character Male NA ## 4 2 7 blank &lt;NA&gt; NA ## 5 3 4 character Matilda NA ## 6 3 5 character Olivia NA ## 7 3 6 character Nicholas NA ## 8 3 7 character Paul NA ## 9 4 2 character Humanities NA ## 10 4 3 character Classics NA ## 11 4 4 numeric &lt;NA&gt; 1 ## 12 4 5 numeric &lt;NA&gt; 2 ## 13 4 6 numeric &lt;NA&gt; 3 ## 14 4 7 numeric &lt;NA&gt; 0 ## 15 5 2 blank &lt;NA&gt; NA ## 16 5 3 character History NA ## 17 5 4 numeric &lt;NA&gt; 3 ## 18 5 5 numeric &lt;NA&gt; 4 ## 19 5 6 numeric &lt;NA&gt; 5 ## 20 5 7 numeric &lt;NA&gt; 1 ## # ... with 12 more rows A similar result is obtained via unpivotr::as_cells(). original &lt;- read_excel(path, sheet = &quot;pivot-annotations&quot;, col_names = FALSE) as_cells(original) %&gt;% arrange(row, col) %&gt;% print(n = 20) ## # A tibble: 36 x 4 ## row col data_type chr ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 1 chr &lt;NA&gt; ## 2 1 2 chr &lt;NA&gt; ## 3 1 3 chr Female ## 4 1 4 chr &lt;NA&gt; ## 5 1 5 chr Male ## 6 1 6 chr &lt;NA&gt; ## 7 2 1 chr &lt;NA&gt; ## 8 2 2 chr &lt;NA&gt; ## 9 2 3 chr Matilda ## 10 2 4 chr Olivia ## 11 2 5 chr Nicholas ## 12 2 6 chr Paul ## 13 3 1 chr Humanities ## 14 3 2 chr Classics ## 15 3 3 chr 1 ## 16 3 4 chr 2 ## 17 3 5 chr 3 ## 18 3 6 chr 0 ## 19 4 1 chr &lt;NA&gt; ## 20 4 2 chr History ## # ... with 16 more rows (One difference is that read_excel() has filled in some missing cells with blanks, which as_cells() retains. Another is that read_excel() has coerced all data types to character, whereas xlsx_cells() preserved the original data types.) The tidyxl version is easier to traverse, because it describes the position of each cell as well as the value. To filter for the first row of headers: dplyr::filter(cells, row == 2, !is_blank) %&gt;% select(row, col, character, numeric) ## # A tibble: 2 x 4 ## row col character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 Female NA ## 2 2 6 Male NA Or to filter for cells containing data (in this case, we know that only data cells are numeric) dplyr::filter(cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, numeric) ## # A tibble: 16 x 3 ## row col numeric ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 4 4 1 ## 2 4 5 2 ## 3 4 6 3 ## 4 4 7 0 ## 5 5 4 3 ## 6 5 5 4 ## 7 5 6 5 ## 8 5 7 1 ## 9 6 4 5 ## 10 6 5 6 ## 11 6 6 9 ## 12 6 7 2 ## 13 7 4 7 ## 14 7 5 8 ## 15 7 6 12 ## 16 7 7 3 By identifying the header cells separately from the data cells, and knowing exactly where they are on the sheet, we can associated the data cells with the relevant headers. To a human it is intuitive that the cells below and to the right of the header Male represent males, and that ones to the right of and below the header Postgraduate qualification represent people with postgraduate qualifications, but it isn’t so obvious to the computer. How would the computer know that the header Male doesn’t also relate to the column of cells below and to the left, beginning with 2? This section shows how you can express the relationships between headers and data cells, using the unpivotr package. "],
["pivot-simple.html", "3.1 Simple unpivoting", " 3.1 Simple unpivoting The behead() function takes one level of headers from a pivot table and makes it part of the data. Think of it like tidyr::gather(), except that it works when there is more than one row of headers (or more than one column of row-headers), and it only works on tables that have first come through as_cells() or tidyxl::xlsx_cells(). 3.1.1 Two clear rows of text column headers, left-aligned Here we have a pivot table with two rows of column headers. The first row of headers is left-aligned, so &quot;Female&quot; applies to the first two columns of data, and &quot;Male&quot; applies to the next two. The second row of headers has a header in every column. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(col &gt;= 4, !is_blank) %&gt;% # Ignore the row headers in this example select(row, col, data_type, character, numeric) all_cells ## # A tibble: 22 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 character Female NA ## 2 2 6 character Male NA ## 3 3 4 character Matilda NA ## 4 3 5 character Olivia NA ## 5 3 6 character Nicholas NA ## 6 3 7 character Paul NA ## 7 4 4 numeric &lt;NA&gt; 1 ## 8 4 5 numeric &lt;NA&gt; 2 ## 9 4 6 numeric &lt;NA&gt; 3 ## 10 4 7 numeric &lt;NA&gt; 0 ## # ... with 12 more rows The behead() function takes the ‘melted’ output of as_cells(), tidyxl::xlsx_cells(), or a previous behead(), and three more arguments to specify how the header cells relate to the data cells. The outermost header is the top row, &quot;Female&quot; NA &quot;Male&quot; NA. The &quot;Female&quot; and &quot;Male&quot; headers are above and to-the-left-of the data cells. We express this as a compass direction, north-north-west, or &quot;NNW&quot;. We also give the headers a name, sex, and say which column of all_cells contains the value of the header cells – it’s usually the character column. all_cells %&gt;% behead(&quot;NNW&quot;, sex) ## # A tibble: 20 x 6 ## row col data_type character numeric sex ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 3 4 character Matilda NA Female ## 2 3 5 character Olivia NA Female ## 3 4 4 numeric &lt;NA&gt; 1 Female ## 4 4 5 numeric &lt;NA&gt; 2 Female ## 5 5 4 numeric &lt;NA&gt; 3 Female ## 6 5 5 numeric &lt;NA&gt; 4 Female ## 7 6 4 numeric &lt;NA&gt; 5 Female ## 8 6 5 numeric &lt;NA&gt; 6 Female ## 9 7 4 numeric &lt;NA&gt; 7 Female ## 10 7 5 numeric &lt;NA&gt; 8 Female ## 11 3 6 character Nicholas NA Male ## 12 3 7 character Paul NA Male ## 13 4 6 numeric &lt;NA&gt; 3 Male ## 14 4 7 numeric &lt;NA&gt; 0 Male ## 15 5 6 numeric &lt;NA&gt; 5 Male ## 16 5 7 numeric &lt;NA&gt; 1 Male ## 17 6 6 numeric &lt;NA&gt; 9 Male ## 18 6 7 numeric &lt;NA&gt; 2 Male ## 19 7 6 numeric &lt;NA&gt; 12 Male ## 20 7 7 numeric &lt;NA&gt; 3 Male That did half the job. The value 2 in row 4 column 5 is indeed a score of a female. But the value &quot;matilda&quot; in row 3 column 4 isn’t a population – it’s another header. The next step is to strip that second level of column headers. This time, the compass direction is &quot;N&quot;, because the headers are directly above the associated data cells, and we call it name, because it represents names of people. all_cells %&gt;% behead(&quot;NNW&quot;, sex) %&gt;% behead(&quot;N&quot;, `name`) ## # A tibble: 16 x 7 ## row col data_type character numeric sex name ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 4 4 numeric &lt;NA&gt; 1 Female Matilda ## 2 4 5 numeric &lt;NA&gt; 2 Female Olivia ## 3 5 4 numeric &lt;NA&gt; 3 Female Matilda ## 4 5 5 numeric &lt;NA&gt; 4 Female Olivia ## 5 6 4 numeric &lt;NA&gt; 5 Female Matilda ## 6 6 5 numeric &lt;NA&gt; 6 Female Olivia ## 7 7 4 numeric &lt;NA&gt; 7 Female Matilda ## 8 7 5 numeric &lt;NA&gt; 8 Female Olivia ## 9 4 6 numeric &lt;NA&gt; 3 Male Nicholas ## 10 4 7 numeric &lt;NA&gt; 0 Male Paul ## 11 5 6 numeric &lt;NA&gt; 5 Male Nicholas ## 12 5 7 numeric &lt;NA&gt; 1 Male Paul ## 13 6 6 numeric &lt;NA&gt; 9 Male Nicholas ## 14 6 7 numeric &lt;NA&gt; 2 Male Paul ## 15 7 6 numeric &lt;NA&gt; 12 Male Nicholas ## 16 7 7 numeric &lt;NA&gt; 3 Male Paul A final step is a normal clean-up. We drop the row, col and character columns, and we rename the numeric column to score, which is what it represents. all_cells %&gt;% behead(&quot;NNW&quot;, sex) %&gt;% behead(&quot;N&quot;, `name`) %&gt;% select(score = numeric, sex, `name`) ## # A tibble: 16 x 3 ## score sex name ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Female Matilda ## 2 2 Female Olivia ## 3 3 Female Matilda ## 4 4 Female Olivia ## 5 5 Female Matilda ## 6 6 Female Olivia ## 7 7 Female Matilda ## 8 8 Female Olivia ## 9 3 Male Nicholas ## 10 0 Male Paul ## 11 5 Male Nicholas ## 12 1 Male Paul ## 13 9 Male Nicholas ## 14 2 Male Paul ## 15 12 Male Nicholas ## 16 3 Male Paul 3.1.2 Two clear rows and columns of text headers, top-aligned and left-aligned There are no new techniques are used, just more compass directions: &quot;W&quot; for headers directly to the left of the data cells, and &quot;WNW&quot; for headers left-and-above the data cells. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric) %&gt;% print() ## # A tibble: 28 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 character Female NA ## 2 2 6 character Male NA ## 3 3 4 character Matilda NA ## 4 3 5 character Olivia NA ## 5 3 6 character Nicholas NA ## 6 3 7 character Paul NA ## 7 4 2 character Humanities NA ## 8 4 3 character Classics NA ## 9 4 4 numeric &lt;NA&gt; 1 ## 10 4 5 numeric &lt;NA&gt; 2 ## # ... with 18 more rows all_cells %&gt;% behead(&quot;NNW&quot;, sex) %&gt;% # As before behead(&quot;N&quot;, `name`) %&gt;% # As before behead(&quot;WNW&quot;, field) %&gt;% # Left-and-above behead(&quot;W&quot;, subject) %&gt;% # Directly left rename(score = numeric) %&gt;% select(-row, -col, -character) ## # A tibble: 16 x 6 ## data_type score sex name field subject ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 numeric 1 Female Matilda Humanities Classics ## 2 numeric 2 Female Olivia Humanities Classics ## 3 numeric 3 Female Matilda Humanities History ## 4 numeric 4 Female Olivia Humanities History ## 5 numeric 3 Male Nicholas Humanities Classics ## 6 numeric 0 Male Paul Humanities Classics ## 7 numeric 5 Male Nicholas Humanities History ## 8 numeric 1 Male Paul Humanities History ## 9 numeric 5 Female Matilda Performance Music ## 10 numeric 6 Female Olivia Performance Music ## 11 numeric 7 Female Matilda Performance Drama ## 12 numeric 8 Female Olivia Performance Drama ## 13 numeric 9 Male Nicholas Performance Music ## 14 numeric 2 Male Paul Performance Music ## 15 numeric 12 Male Nicholas Performance Drama ## 16 numeric 3 Male Paul Performance Drama 3.1.3 Multiple rows or columns of headers, with meaningful formatting This is a combination of the previous section with meaningfully formatted rows. The section meaninfully formatted cells doesn’t work here, because the unpivoting of multiple rows/columns of headers complicates the relationship between the data and the formatting. Unpivot the multiple rows/columns of headers, as above, but keep the row and col of each data cell. Collect the row, col and formatting of each data cell. Join the data to the formatting by the row and col. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric) %&gt;% print() ## # A tibble: 28 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 character Female NA ## 2 2 6 character Male NA ## 3 3 4 character Matilda NA ## 4 3 5 character Olivia NA ## 5 3 6 character Nicholas NA ## 6 3 7 character Paul NA ## 7 4 2 character Humanities NA ## 8 4 3 character Classics NA ## 9 4 4 numeric &lt;NA&gt; 1 ## 10 4 5 numeric &lt;NA&gt; 2 ## # ... with 18 more rows unpivoted &lt;- all_cells %&gt;% behead(&quot;NNW&quot;, sex) %&gt;% # As before behead(&quot;N&quot;, `name`) %&gt;% # As before behead(&quot;WNW&quot;, field) %&gt;% # Left-and-above behead(&quot;W&quot;, subject) %&gt;% # Directly left rename(score = numeric) %&gt;% select(-character) # Retain the row and col for now unpivoted ## # A tibble: 16 x 8 ## row col data_type score sex name field subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 4 4 numeric 1 Female Matilda Humanities Classics ## 2 4 5 numeric 2 Female Olivia Humanities Classics ## 3 5 4 numeric 3 Female Matilda Humanities History ## 4 5 5 numeric 4 Female Olivia Humanities History ## 5 4 6 numeric 3 Male Nicholas Humanities Classics ## 6 4 7 numeric 0 Male Paul Humanities Classics ## 7 5 6 numeric 5 Male Nicholas Humanities History ## 8 5 7 numeric 1 Male Paul Humanities History ## 9 6 4 numeric 5 Female Matilda Performance Music ## 10 6 5 numeric 6 Female Olivia Performance Music ## 11 7 4 numeric 7 Female Matilda Performance Drama ## 12 7 5 numeric 8 Female Olivia Performance Drama ## 13 6 6 numeric 9 Male Nicholas Performance Music ## 14 6 7 numeric 2 Male Paul Performance Music ## 15 7 6 numeric 12 Male Nicholas Performance Drama ## 16 7 7 numeric 3 Male Paul Performance Drama # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb fill_colours ## [1] NA NA NA NA NA NA ## [7] NA NA &quot;FFFFFF00&quot; &quot;FF92D050&quot; &quot;FFFFFF00&quot; NA ## [13] NA &quot;FFFFFF00&quot; NA NA NA NA ## [19] NA NA NA &quot;FFFFFF00&quot; &quot;FFFFFF00&quot; NA ## [25] NA &quot;FFFFFF00&quot; NA NA NA NA ## [31] NA NA NA NA NA NA ## [37] NA NA NA NA NA NA ## [43] NA NA NA NA NA NA ## [49] NA NA NA NA NA NA ## [55] NA NA &quot;FFFFC7CE&quot; NA NA # Import all the cells, filter out the header row, filter for the first column, # and create a new column `approximate` based on the fill colours, by looking up # the local_format_id of each cell in the `formats` pallette. annotations &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(row &gt;= 4, col &gt;= 4) %&gt;% # Omit the headers mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, fill_colour) annotations ## # A tibble: 16 x 3 ## row col fill_colour ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 4 &lt;NA&gt; ## 2 4 5 FFFFFF00 ## 3 4 6 &lt;NA&gt; ## 4 4 7 &lt;NA&gt; ## 5 5 4 FFFFFF00 ## 6 5 5 &lt;NA&gt; ## 7 5 6 &lt;NA&gt; ## 8 5 7 &lt;NA&gt; ## 9 6 4 &lt;NA&gt; ## 10 6 5 &lt;NA&gt; ## 11 6 6 &lt;NA&gt; ## 12 6 7 &lt;NA&gt; ## 13 7 4 &lt;NA&gt; ## 14 7 5 &lt;NA&gt; ## 15 7 6 FFFFFF00 ## 16 7 7 &lt;NA&gt; left_join(unpivoted, annotations, by = c(&quot;row&quot;, &quot;col&quot;)) %&gt;% select(-row, -col) ## # A tibble: 16 x 7 ## data_type score sex name field subject fill_colour ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 numeric 1 Female Matilda Humanities Classics &lt;NA&gt; ## 2 numeric 2 Female Olivia Humanities Classics FFFFFF00 ## 3 numeric 3 Female Matilda Humanities History FFFFFF00 ## 4 numeric 4 Female Olivia Humanities History &lt;NA&gt; ## 5 numeric 3 Male Nicholas Humanities Classics &lt;NA&gt; ## 6 numeric 0 Male Paul Humanities Classics &lt;NA&gt; ## 7 numeric 5 Male Nicholas Humanities History &lt;NA&gt; ## 8 numeric 1 Male Paul Humanities History &lt;NA&gt; ## 9 numeric 5 Female Matilda Performance Music &lt;NA&gt; ## 10 numeric 6 Female Olivia Performance Music &lt;NA&gt; ## 11 numeric 7 Female Matilda Performance Drama &lt;NA&gt; ## 12 numeric 8 Female Olivia Performance Drama &lt;NA&gt; ## 13 numeric 9 Male Nicholas Performance Music &lt;NA&gt; ## 14 numeric 2 Male Paul Performance Music &lt;NA&gt; ## 15 numeric 12 Male Nicholas Performance Drama FFFFFF00 ## 16 numeric 3 Male Paul Performance Drama &lt;NA&gt; "],
["pivot-complex.html", "3.2 Complex unpivoting", " 3.2 Complex unpivoting When behead() isn’t powerful enough (it makes certain assumptions, and it doesn’t understand formatting), then you can get much more control by using enhead(), which joins together two separate data frames of data cells and header cells. This kind of unpivoting is always done in two stages. Identify which cells are headers, and which are data State how the data cells relate to the header cells. 3.2.1 Two clear rows of text column headers, left-aligned {#2RL} The first stage, identifying header vs data cells, is simply filtering. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(col &gt;= 4, !is_blank) %&gt;% # Ignore the row headers in this example select(row, col, data_type, character, numeric) %&gt;% print() ## # A tibble: 22 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 character Female NA ## 2 2 6 character Male NA ## 3 3 4 character Matilda NA ## 4 3 5 character Olivia NA ## 5 3 6 character Nicholas NA ## 6 3 7 character Paul NA ## 7 4 4 numeric &lt;NA&gt; 1 ## 8 4 5 numeric &lt;NA&gt; 2 ## 9 4 6 numeric &lt;NA&gt; 3 ## 10 4 7 numeric &lt;NA&gt; 0 ## # ... with 12 more rows # View the cells in their original positions on the spreadsheet rectify(all_cells) ## # A tibble: 6 x 5 ## `row/col` `4(D)` `5(E)` `6(F)` `7(G)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 Female &lt;NA&gt; Male &lt;NA&gt; ## 2 3 Matilda Olivia Nicholas Paul ## 3 4 1 2 3 0 ## 4 5 3 4 5 1 ## 5 6 5 6 9 2 ## 6 7 7 8 12 3 first_header_row &lt;- dplyr::filter(all_cells, row == 2) %&gt;% select(row, col, sex = character) # the title of this header is &#39;sex&#39; # the cells are text cells (`&quot;Female&quot;` and `&quot;Male&quot;`) so take the value in the # &#39;`character` column. first_header_row ## # A tibble: 2 x 3 ## row col sex ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 4 Female ## 2 2 6 Male second_header_row &lt;- dplyr::filter(all_cells, row == 3) %&gt;% select(row, col, name = character) # The title of this header is &#39;name&#39;. # The cells are text cells, so take the value in the &#39;`character` column. second_header_row ## # A tibble: 4 x 3 ## row col name ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 4 Matilda ## 2 3 5 Olivia ## 3 3 6 Nicholas ## 4 3 7 Paul data_cells &lt;- dplyr::filter(all_cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, score = numeric) # The data is exam scores in certain subjects, so give the data that title. # The data is numeric, so select only that &#39;value&#39;. If some of the data was # also text or true/false, then you would select the `character` and `logical` # columns as well as `numeric` The second stage is to declare how the data cells relate to each row of column headers. Unpivotr provides a set of functions for this, derived from the points of the compass. Starting from the point of view of a data cell, the relevant column header from the second row of headers is the one directly north (up), or &quot;N&quot;. enhead(data_cells, second_header_row, &quot;N&quot;) ## # A tibble: 16 x 4 ## row col score name ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 4 4 1 Matilda ## 2 4 5 2 Olivia ## 3 4 6 3 Nicholas ## 4 4 7 0 Paul ## 5 5 4 3 Matilda ## 6 5 5 4 Olivia ## 7 5 6 5 Nicholas ## 8 5 7 1 Paul ## 9 6 4 5 Matilda ## 10 6 5 6 Olivia ## 11 6 6 9 Nicholas ## 12 6 7 2 Paul ## 13 7 4 7 Matilda ## 14 7 5 8 Olivia ## 15 7 6 12 Nicholas ## 16 7 7 3 Paul The first row of headers, from the point of view of a data cell, is either directly north (up), or north and west (up and left), or &quot;NNW&quot;. enhead(data_cells, first_header_row, &quot;NNW&quot;) ## # A tibble: 16 x 4 ## row col score sex ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 4 4 1 Female ## 2 4 5 2 Female ## 3 5 4 3 Female ## 4 5 5 4 Female ## 5 6 4 5 Female ## 6 6 5 6 Female ## 7 7 4 7 Female ## 8 7 5 8 Female ## 9 4 6 3 Male ## 10 4 7 0 Male ## 11 5 6 5 Male ## 12 5 7 1 Male ## 13 6 6 9 Male ## 14 6 7 2 Male ## 15 7 6 12 Male ## 16 7 7 3 Male Piping everything together, we get a complete, tidy dataset, and can finally drop the row and col columns. data_cells %&gt;% enhead(first_header_row, &quot;NNW&quot;) %&gt;% enhead(second_header_row, &quot;N&quot;) %&gt;% select(-row, -col) ## # A tibble: 16 x 3 ## score sex name ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Female Matilda ## 2 2 Female Olivia ## 3 3 Female Matilda ## 4 4 Female Olivia ## 5 5 Female Matilda ## 6 6 Female Olivia ## 7 7 Female Matilda ## 8 8 Female Olivia ## 9 3 Male Nicholas ## 10 0 Male Paul ## 11 5 Male Nicholas ## 12 1 Male Paul ## 13 9 Male Nicholas ## 14 2 Male Paul ## 15 12 Male Nicholas ## 16 3 Male Paul 3.2.2 Two clear columns of text row headers, top-aligned This is almost the same as Two clear rows of text column headers, left-aligned, but with different compass directions: &quot;W&quot; for directly west (left), and &quot;WNW&quot; for west and north (left and up). (&quot;NNW&quot; and &quot;WNW&quot; look like synonyms. They happen to be synonyms in enhead(), but they aren’t in behead(). In this example, the table has no column headers, only row headers. This is artificial here, but sometimes table are deliberately laid out in transpose form: the first column contains the headers, and the data extends in columns from left to right instead of from top to bottom. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(row &gt;= 3, !is_blank) %&gt;% # Ignore the column headers in this example select(row, col, data_type, character, numeric) %&gt;% print() ## # A tibble: 26 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 3 4 character Matilda NA ## 2 3 5 character Olivia NA ## 3 3 6 character Nicholas NA ## 4 3 7 character Paul NA ## 5 4 2 character Humanities NA ## 6 4 3 character Classics NA ## 7 4 4 numeric &lt;NA&gt; 1 ## 8 4 5 numeric &lt;NA&gt; 2 ## 9 4 6 numeric &lt;NA&gt; 3 ## 10 4 7 numeric &lt;NA&gt; 0 ## # ... with 16 more rows # View the cells in their original positions on the spreadsheet rectify(all_cells) ## # A tibble: 5 x 7 ## `row/col` `2(B)` `3(C)` `4(D)` `5(E)` `6(F)` `7(G)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 3 &lt;NA&gt; &lt;NA&gt; Matilda Olivia Nicholas Paul ## 2 4 Humanities Classics 1 2 3 0 ## 3 5 &lt;NA&gt; History 3 4 5 1 ## 4 6 Performance Music 5 6 9 2 ## 5 7 &lt;NA&gt; Drama 7 8 12 3 first_header_col &lt;- dplyr::filter(all_cells, col == 2) %&gt;% select(row, col, field = character) # the title of this header is &#39;field&#39;, meaning &#39;group of subjects&#39;. # The cells are text cells (`&quot;Humanities&quot;`, `&quot;Performance&quot;`) so take the value # in the &#39;`character` column. first_header_col ## # A tibble: 2 x 3 ## row col field ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 2 Humanities ## 2 6 2 Performance second_header_col &lt;- dplyr::filter(all_cells, col == 3) %&gt;% select(row, col, subject = character) # The title of this header is &#39;subject&#39; # The cells are text cells (`&quot;history&quot;`, etc.) so take the value in the # &#39;`character` column. second_header_col ## # A tibble: 4 x 3 ## row col subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 3 Classics ## 2 5 3 History ## 3 6 3 Music ## 4 7 3 Drama data_cells &lt;- dplyr::filter(all_cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, score = numeric) # The data is examp scores in certain subjects, so give the data that title. # The data is numeric, so select only that &#39;value&#39;. If some of the data was # also text or true/false, then you would select the `character` and `logical` # columns as well as `numeric` data_cells %&gt;% enhead(first_header_col, &quot;WNW&quot;) %&gt;% enhead(second_header_col, &quot;W&quot;) %&gt;% select(-row, -col) ## # A tibble: 16 x 3 ## score field subject ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Humanities Classics ## 2 2 Humanities Classics ## 3 3 Humanities Classics ## 4 0 Humanities Classics ## 5 3 Humanities History ## 6 4 Humanities History ## 7 5 Humanities History ## 8 1 Humanities History ## 9 5 Performance Music ## 10 6 Performance Music ## 11 9 Performance Music ## 12 2 Performance Music ## 13 7 Performance Drama ## 14 8 Performance Drama ## 15 12 Performance Drama ## 16 3 Performance Drama 3.2.3 Two clear rows and columns of text headers, top-aligned and left-aligned This is a combination of the previous two sections. No new techniques are used. Identify which cells are headers, and which are data State how the data cells relate to the header cells. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric) %&gt;% print() ## # A tibble: 28 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 character Female NA ## 2 2 6 character Male NA ## 3 3 4 character Matilda NA ## 4 3 5 character Olivia NA ## 5 3 6 character Nicholas NA ## 6 3 7 character Paul NA ## 7 4 2 character Humanities NA ## 8 4 3 character Classics NA ## 9 4 4 numeric &lt;NA&gt; 1 ## 10 4 5 numeric &lt;NA&gt; 2 ## # ... with 18 more rows # View the cells in their original positions on the spreadsheet rectify(all_cells) ## # A tibble: 6 x 7 ## `row/col` `2(B)` `3(C)` `4(D)` `5(E)` `6(F)` `7(G)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 &lt;NA&gt; &lt;NA&gt; Female &lt;NA&gt; Male &lt;NA&gt; ## 2 3 &lt;NA&gt; &lt;NA&gt; Matilda Olivia Nicholas Paul ## 3 4 Humanities Classics 1 2 3 0 ## 4 5 &lt;NA&gt; History 3 4 5 1 ## 5 6 Performance Music 5 6 9 2 ## 6 7 &lt;NA&gt; Drama 7 8 12 3 first_header_row &lt;- dplyr::filter(all_cells, row == 2) %&gt;% select(row, col, sex = character) # the title of this header is &#39;sex&#39; # the cells are text cells (`&quot;Female&quot;` and `&quot;Male&quot;`) so take the value in the # &#39;`character` column. first_header_row ## # A tibble: 2 x 3 ## row col sex ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 4 Female ## 2 2 6 Male second_header_row &lt;- dplyr::filter(all_cells, row == 3) %&gt;% select(row, col, name = character) # The title of this header is &#39;name&#39;. # The cells are text cells, so take the value in the &#39;`character` column. second_header_row ## # A tibble: 4 x 3 ## row col name ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 4 Matilda ## 2 3 5 Olivia ## 3 3 6 Nicholas ## 4 3 7 Paul first_header_col &lt;- dplyr::filter(all_cells, col == 2) %&gt;% select(row, col, field = character) # the title of this header is &#39;field&#39;, meaning &#39;group of subjects&#39;. # The cells are text cells (`&quot;Humanities&quot;`, `&quot;Performance&quot;`) so take the value # in the &#39;`character` column. first_header_col ## # A tibble: 2 x 3 ## row col field ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 2 Humanities ## 2 6 2 Performance second_header_col &lt;- dplyr::filter(all_cells, col == 3) %&gt;% select(row, col, subject = character) # The title of this header is &#39;subject&#39; # The cells are text cells (`&quot;history&quot;`, etc.) so take the value in the # &#39;`character` column. second_header_col ## # A tibble: 4 x 3 ## row col subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 3 Classics ## 2 5 3 History ## 3 6 3 Music ## 4 7 3 Drama data_cells &lt;- dplyr::filter(all_cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, score = numeric) # The data is examp scores in certain subjects, so give the data that title. # The data is numeric, so select only that &#39;value&#39;. If some of the data was # also text or true/false, then you would select the `character` and `logical` # columns as well as `numeric` data_cells %&gt;% enhead(first_header_row, &quot;NNW&quot;) %&gt;% enhead(second_header_row, &quot;N&quot;) %&gt;% enhead(first_header_col, &quot;WNW&quot;) %&gt;% enhead(second_header_col, &quot;W&quot;) %&gt;% select(-row, -col) ## # A tibble: 16 x 5 ## score sex name field subject ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Female Matilda Humanities Classics ## 2 2 Female Olivia Humanities Classics ## 3 3 Female Matilda Humanities History ## 4 4 Female Olivia Humanities History ## 5 3 Male Nicholas Humanities Classics ## 6 0 Male Paul Humanities Classics ## 7 5 Male Nicholas Humanities History ## 8 1 Male Paul Humanities History ## 9 5 Female Matilda Performance Music ## 10 6 Female Olivia Performance Music ## 11 7 Female Matilda Performance Drama ## 12 8 Female Olivia Performance Drama ## 13 9 Male Nicholas Performance Music ## 14 2 Male Paul Performance Music ## 15 12 Male Nicholas Performance Drama ## 16 3 Male Paul Performance Drama 3.2.4 Centre-aligned headers Headers aren’t always aligned to one side of the data cells that they describe. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-centre-aligned&quot;) rectify(all_cells) ## # A tibble: 10 x 10 ## `row/col` `2(B)` `3(C)` `4(D)` `5(E)` `6(F)` `7(G)` `8(H)` `9(I)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Female &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Male ## 2 3 &lt;NA&gt; &lt;NA&gt; Leah Matil… Olivia Lenny Max Nichol… ## 3 4 &lt;NA&gt; Classics 3 1 2 4 3 3 ## 4 5 Humaniti… History 8 3 4 7 5 5 ## 5 6 &lt;NA&gt; Literat… 1 1 9 3 12 7 ## 6 7 &lt;NA&gt; Philoso… 5 10 10 8 2 5 ## 7 8 &lt;NA&gt; Languag… 5 4 5 9 8 3 ## 8 9 &lt;NA&gt; Music 4 10 10 2 4 5 ## 9 10 Performa… Dance 4 5 6 4 12 9 ## 10 11 &lt;NA&gt; Drama 2 7 8 6 1 12 ## # ... with 1 more variable: `10(J)` &lt;chr&gt; Looking at that table, it’s not immediately obvious where the boundary between Female and Male falls, or between Humanities and Performance. A naive approach would be to match the inner headers to the outer ones by proximity, and there are four directions to do so: &quot;ABOVE&quot;, &quot;LEFT&quot;, &quot;BELOW&quot;, and &quot;RIGHT&quot;. But in this case, those directions are too naive. Languages is closest to the Performance header, but is a humanity. Lenny is the same distance from Female as from Male. You can fix this by justifying the header cells towards one side of the data cells that they describe, and then use a direction like &quot;NNW&quot; as usual. Do this with justify(), providing the header cells with a second set of cells at the positions you want the header cells to move to. header_cells is the cells whose value will be used as the header corner_cells is the cells whose position is in one corner of the domain of the header (e.g. the top-left-hand corner). In the original spreadsheet, the borders mark the boundaries. So the corner cells of the headers can be found by filtering for cells with a particular border. all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-centre-aligned&quot;) %&gt;% select(row, col, is_blank, data_type, character, numeric, local_format_id) formats &lt;- xlsx_formats(path) top_borders &lt;- which(!is.na(formats$local$border$top$style)) left_borders &lt;- which(!is.na(formats$local$border$left$style)) first_header_row_corners &lt;- dplyr::filter(all_cells, row == 2, local_format_id %in% left_borders) %&gt;% select(row, col) first_header_row_corners ## # A tibble: 2 x 2 ## row col ## &lt;int&gt; &lt;int&gt; ## 1 2 4 ## 2 2 7 first_header_col_corners &lt;- dplyr::filter(all_cells, col == 2, local_format_id %in% top_borders) %&gt;% select(row, col) first_header_col_corners ## # A tibble: 2 x 2 ## row col ## &lt;int&gt; &lt;int&gt; ## 1 4 2 ## 2 9 2 Next, get the first row and first column of header cells as usual. first_header_row &lt;- dplyr::filter(all_cells, !is_blank, row == 2) %&gt;% select(row, col, sex = character) # the title of this header is &#39;sex&#39; # the cells are text cells (`&quot;Female&quot;` and `&quot;Male&quot;`) so take the value in the # &#39;`character` column. first_header_row ## # A tibble: 2 x 3 ## row col sex ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 5 Female ## 2 2 9 Male first_header_col &lt;- dplyr::filter(all_cells, !is_blank, col == 2) %&gt;% select(row, col, field = character) # the title of this header is &#39;field&#39;, meaning &#39;group of subjects&#39;. # The cells are text cells (`&quot;Humanities&quot;`, `&quot;Performance&quot;`) so take the value # in the &#39;`character` column. first_header_col ## # A tibble: 2 x 3 ## row col field ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 5 2 Humanities ## 2 10 2 Performance And now justify the header cells to the same positions as the corner cells. first_header_row &lt;- justify(first_header_row, first_header_row_corners) first_header_col &lt;- justify(first_header_col, first_header_col_corners) first_header_row ## # A tibble: 2 x 3 ## row col sex ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 4 Female ## 2 2 7 Male first_header_col ## # A tibble: 2 x 3 ## row col field ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 2 Humanities ## 2 9 2 Performance The rest of this example is the same as “Two clear rows and columns of text headers, top-aligned and left-aligned”. second_header_row &lt;- dplyr::filter(all_cells, row == 3) %&gt;% select(row, col, name = character) # The title of this header is &#39;name&#39;. # The cells are text cells, so take the value in the &#39;`character` column. second_header_row ## # A tibble: 7 x 3 ## row col name ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 4 Leah ## 2 3 5 Matilda ## 3 3 6 Olivia ## 4 3 7 Lenny ## 5 3 8 Max ## 6 3 9 Nicholas ## 7 3 10 Paul second_header_col &lt;- dplyr::filter(all_cells, col == 3) %&gt;% select(row, col, subject = character) # The title of this header is &#39;subject&#39; # The cells are text cells (`&quot;history&quot;`, etc.) so take the value in the # &#39;`character` column. second_header_col ## # A tibble: 8 x 3 ## row col subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 3 Classics ## 2 5 3 History ## 3 6 3 Literature ## 4 7 3 Philosophy ## 5 8 3 Languages ## 6 9 3 Music ## 7 10 3 Dance ## 8 11 3 Drama data_cells &lt;- dplyr::filter(all_cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, score = numeric) # The data is examp scores in certain subjects, so give the data that title. # The data is numeric, so select only that &#39;value&#39;. If some of the data was # also text or true/false, then you would select the `character` and `logical` # columns as well as `numeric` data_cells %&gt;% enhead(first_header_row, &quot;NNW&quot;) %&gt;% enhead(second_header_row, &quot;N&quot;) %&gt;% enhead(first_header_col, &quot;WNW&quot;) %&gt;% enhead(second_header_col, &quot;W&quot;) %&gt;% select(-row, -col) ## # A tibble: 56 x 5 ## score sex name field subject ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 3 Female Leah Humanities Classics ## 2 1 Female Matilda Humanities Classics ## 3 2 Female Olivia Humanities Classics ## 4 8 Female Leah Humanities History ## 5 3 Female Matilda Humanities History ## 6 4 Female Olivia Humanities History ## 7 1 Female Leah Humanities Literature ## 8 1 Female Matilda Humanities Literature ## 9 9 Female Olivia Humanities Literature ## 10 5 Female Leah Humanities Philosophy ## # ... with 46 more rows 3.2.5 Multiple rows or columns of headers, with meaningful formatting This is a combination of the previous section with Meaningfully formatted cells. The section Meaningfully formatted rows doesn’t work here, because the unpivoting of multiple rows/columns of headers complicates the relationship between the data and the formatting. Unpivot the multiple rows/columns of headers, as above, but keep the row and col of each data cell. Collect the row, col and formatting of each data cell. Join the data to the formatting by the row and col. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric) %&gt;% print() ## # A tibble: 28 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 character Female NA ## 2 2 6 character Male NA ## 3 3 4 character Matilda NA ## 4 3 5 character Olivia NA ## 5 3 6 character Nicholas NA ## 6 3 7 character Paul NA ## 7 4 2 character Humanities NA ## 8 4 3 character Classics NA ## 9 4 4 numeric &lt;NA&gt; 1 ## 10 4 5 numeric &lt;NA&gt; 2 ## # ... with 18 more rows # View the cells in their original positions on the spreadsheet rectify(all_cells) ## # A tibble: 6 x 7 ## `row/col` `2(B)` `3(C)` `4(D)` `5(E)` `6(F)` `7(G)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 &lt;NA&gt; &lt;NA&gt; Female &lt;NA&gt; Male &lt;NA&gt; ## 2 3 &lt;NA&gt; &lt;NA&gt; Matilda Olivia Nicholas Paul ## 3 4 Humanities Classics 1 2 3 0 ## 4 5 &lt;NA&gt; History 3 4 5 1 ## 5 6 Performance Music 5 6 9 2 ## 6 7 &lt;NA&gt; Drama 7 8 12 3 first_header_row &lt;- dplyr::filter(all_cells, row == 2) %&gt;% select(row, col, sex = character) # the title of this header is &#39;sex&#39; # the cells are text cells (`&quot;Female&quot;` and `&quot;Male&quot;`) so take the value in the # &#39;`character` column. first_header_row ## # A tibble: 2 x 3 ## row col sex ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 4 Female ## 2 2 6 Male second_header_row &lt;- dplyr::filter(all_cells, row == 3) %&gt;% select(row, col, name = character) # The title of this header is &#39;name&#39;. # The cells are text cells, so take the value in the &#39;`character` column. second_header_row ## # A tibble: 4 x 3 ## row col name ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 4 Matilda ## 2 3 5 Olivia ## 3 3 6 Nicholas ## 4 3 7 Paul first_header_col &lt;- dplyr::filter(all_cells, col == 2) %&gt;% select(row, col, field = character) # the title of this header is &#39;field&#39;, meaning &#39;group of subjects&#39;. # The cells are text cells (`&quot;Humanities&quot;`, `&quot;Performance&quot;`) so take the value # in the &#39;`character` column. first_header_col ## # A tibble: 2 x 3 ## row col field ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 2 Humanities ## 2 6 2 Performance second_header_col &lt;- dplyr::filter(all_cells, col == 3) %&gt;% select(row, col, subject = character) # The title of this header is &#39;subject&#39; # The cells are text cells (`&quot;history&quot;`, etc.) so take the value in the # &#39;`character` column. second_header_col ## # A tibble: 4 x 3 ## row col subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 3 Classics ## 2 5 3 History ## 3 6 3 Music ## 4 7 3 Drama data_cells &lt;- dplyr::filter(all_cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, score = numeric) # The data is exam scores in certain subjects, so give the data that title. # The data is numeric, so select only that &#39;value&#39;. If some of the data was # also text or true/false, then you would select the `character` and `logical` # columns as well as `numeric` unpivoted &lt;- data_cells %&gt;% enhead(first_header_row, &quot;NNW&quot;) %&gt;% enhead(second_header_row, &quot;N&quot;) %&gt;% enhead(first_header_col, &quot;WNW&quot;) %&gt;% enhead(second_header_col, &quot;W&quot;) # Don&#39;t delet the `row` and `col` columns yet, because we need them to join on # the formatting # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb # Import all the cells, filter out the header row, filter for the first column, # and create a new column `approximate` based on the fill colours, by looking up # the local_format_id of each cell in the `formats` pallette. annotations &lt;- xlsx_cells(path, sheets = &quot;pivot-annotations&quot;) %&gt;% dplyr::filter(row &gt;= 4, col &gt;= 4) %&gt;% # Omit the headers mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, fill_colour) annotations ## # A tibble: 16 x 3 ## row col fill_colour ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 4 &lt;NA&gt; ## 2 4 5 FFFFFF00 ## 3 4 6 &lt;NA&gt; ## 4 4 7 &lt;NA&gt; ## 5 5 4 FFFFFF00 ## 6 5 5 &lt;NA&gt; ## 7 5 6 &lt;NA&gt; ## 8 5 7 &lt;NA&gt; ## 9 6 4 &lt;NA&gt; ## 10 6 5 &lt;NA&gt; ## 11 6 6 &lt;NA&gt; ## 12 6 7 &lt;NA&gt; ## 13 7 4 &lt;NA&gt; ## 14 7 5 &lt;NA&gt; ## 15 7 6 FFFFFF00 ## 16 7 7 &lt;NA&gt; left_join(unpivoted, annotations, by = c(&quot;row&quot;, &quot;col&quot;)) %&gt;% select(-row, -col) ## # A tibble: 16 x 6 ## score sex name field subject fill_colour ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Female Matilda Humanities Classics &lt;NA&gt; ## 2 2 Female Olivia Humanities Classics FFFFFF00 ## 3 3 Female Matilda Humanities History FFFFFF00 ## 4 4 Female Olivia Humanities History &lt;NA&gt; ## 5 3 Male Nicholas Humanities Classics &lt;NA&gt; ## 6 0 Male Paul Humanities Classics &lt;NA&gt; ## 7 5 Male Nicholas Humanities History &lt;NA&gt; ## 8 1 Male Paul Humanities History &lt;NA&gt; ## 9 5 Female Matilda Performance Music &lt;NA&gt; ## 10 6 Female Olivia Performance Music &lt;NA&gt; ## 11 7 Female Matilda Performance Drama &lt;NA&gt; ## 12 8 Female Olivia Performance Drama &lt;NA&gt; ## 13 9 Male Nicholas Performance Music &lt;NA&gt; ## 14 2 Male Paul Performance Music &lt;NA&gt; ## 15 12 Male Nicholas Performance Drama FFFFFF00 ## 16 3 Male Paul Performance Drama &lt;NA&gt; 3.2.6 Mixed headers and notes in the same row/column, distinguished by formatting This doesn’t use any new techniques. The trick is, when selecting a row or column of header cells, to filter out ones that have the ‘wrong’ formatting (formatting that shows they aren’t really headers). In this example, cells with italic or red text aren’t headers, even if they are in amongst header cells. First, identify the IDs of formats that have italic or red text. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) formats &lt;- xlsx_formats(path) italic &lt;- which(formats$local$font$italic) # For &#39;red&#39; we can either look for the RGB code for red &quot;FFFF0000&quot; red &lt;- which(formats$local$font$color$rgb == &quot;FFFF0000&quot;) red ## [1] 12 13 14 40 41 # Or we can find out what that code is by starting from a cell that we know is # red. red_cell_format_id &lt;- xlsx_cells(path, sheets = &quot;pivot-notes&quot;) %&gt;% dplyr::filter(row == 5, col == 2) %&gt;% pull(local_format_id) red_cell_format_id ## [1] 40 red_rgb &lt;- formats$local$font$color$rgb[red_cell_format_id] red &lt;- which(formats$local$font$color$rgb == red_rgb) red ## [1] 12 13 14 40 41 Now we select the headers, filtering out cells with the format IDs of red or italic cells. all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-notes&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, character, numeric, local_format_id) %&gt;% print() ## # A tibble: 31 x 5 ## row col character numeric local_format_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2 4 Female NA 18 ## 2 2 6 Male NA 18 ## 3 2 7 0 = absent NA 39 ## 4 3 4 Matilda NA 20 ## 5 3 5 Olivia NA 21 ## 6 3 6 Nicholas NA 20 ## 7 3 7 Paul NA 21 ## 8 4 2 Humanities NA 18 ## 9 4 3 Classics NA 19 ## 10 4 4 &lt;NA&gt; 1 33 ## # ... with 21 more rows first_header_row &lt;- dplyr::filter(all_cells, row == 2, !(local_format_id %in% c(red, italic))) %&gt;% select(row, col, sex = character) # the title of this header is &#39;sex&#39; # the cells are text cells (`&quot;Female&quot;` and `&quot;Male&quot;`) so take the value in the # &#39;`character` column. first_header_row ## # A tibble: 2 x 3 ## row col sex ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 4 Female ## 2 2 6 Male first_header_col &lt;- dplyr::filter(all_cells, col == 2, !(local_format_id %in% c(red, italic))) %&gt;% select(row, col, qualification = character) # the title of this header is &#39;field&#39;, meaning &#39;group of subjects&#39;. # The cells are text cells (`&quot;Humanities&quot;`, `&quot;Performance&quot;`) so take the value # in the &#39;`character` column. first_header_col ## # A tibble: 2 x 3 ## row col qualification ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 2 Humanities ## 2 6 2 Performance second_header_col &lt;- dplyr::filter(all_cells, col == 3) %&gt;% select(row, col, subject = character) # The title of this header is &#39;subject&#39; # The cells are text cells (`&quot;history&quot;`, etc.) so take the value in the # &#39;`character` column. data_cells %&gt;% enhead(first_header_row, &quot;NNW&quot;) %&gt;% enhead(first_header_col, &quot;WNW&quot;) %&gt;% select(-row, -col) ## # A tibble: 16 x 3 ## score sex qualification ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Female Humanities ## 2 2 Female Humanities ## 3 3 Female Humanities ## 4 4 Female Humanities ## 5 3 Male Humanities ## 6 0 Male Humanities ## 7 5 Male Humanities ## 8 1 Male Humanities ## 9 5 Female Performance ## 10 6 Female Performance ## 11 7 Female Performance ## 12 8 Female Performance ## 13 9 Male Performance ## 14 2 Male Performance ## 15 12 Male Performance ## 16 3 Male Performance 3.2.7 Mixed levels of headers in the same row/column, distinguished by formatting Normally different levels of headers are in different rows, or different columns, like Two clear rows of text column headers, left-aligned. But sometimes they coexist in the same row or column, and are distinguishable by formatting, e.g. bold for the top level, italic for the mid level, and plain for the lowest level. In this example, there is a single column of row headers, where the levels are shown by different amounts of indentation. The indentation is done by formatting, rather than by leading spaces or tabs. The first step is to find the format IDs of all the different levels of indentation. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) formats &lt;- xlsx_formats(path) indent0 &lt;- which(formats$local$alignment$indent == 0) indent1 &lt;- which(formats$local$alignment$indent == 1) indent0 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## [24] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 45 47 48 ## [47] 49 50 51 52 53 54 55 56 57 58 59 indent1 ## [1] 44 46 Now we use these format IDs to indentify the different levels of headers in the first column. all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-hierarchy&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric, local_format_id) %&gt;% print() ## # A tibble: 16 x 6 ## row col data_type character numeric local_format_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2 3 character Matilda NA 18 ## 2 2 4 character Nicholas NA 42 ## 3 3 2 character Humanities NA 18 ## 4 4 2 character Classics NA 44 ## 5 4 3 numeric &lt;NA&gt; 1 20 ## 6 4 4 numeric &lt;NA&gt; 3 45 ## 7 5 2 character History NA 44 ## 8 5 3 numeric &lt;NA&gt; 3 20 ## 9 5 4 numeric &lt;NA&gt; 5 45 ## 10 6 2 character Performance NA 20 ## 11 7 2 character Music NA 44 ## 12 7 3 numeric &lt;NA&gt; 5 20 ## 13 7 4 numeric &lt;NA&gt; 9 45 ## 14 8 2 character Drama NA 46 ## 15 8 3 numeric &lt;NA&gt; 7 24 ## 16 8 4 numeric &lt;NA&gt; 12 47 field &lt;- dplyr::filter(all_cells, col == 2, local_format_id %in% indent0) %&gt;% select(row, col, field = character) # the title of this header is &#39;field&#39;, meaning &#39;group of subjects&#39;. # The cells are text cells (`&quot;Humanities&quot;`, `&quot;Performance&quot;`) so take the value # in the &#39;`character` column. field ## # A tibble: 2 x 3 ## row col field ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 2 Humanities ## 2 6 2 Performance subject &lt;- dplyr::filter(all_cells, col == 2, local_format_id %in% indent1) %&gt;% select(row, col, subject = character) # The title of this header is &#39;subject&#39; # The cells are text cells (`&quot;history&quot;`, etc.) so take the value in the # &#39;`character` column. subject ## # A tibble: 4 x 3 ## row col subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 2 Classics ## 2 5 2 History ## 3 7 2 Music ## 4 8 2 Drama name &lt;- dplyr::filter(all_cells, row == 2) %&gt;% select(row, col, name = character) # The title of this header is &#39;name&#39;. # The cells are text cells, so take the value in the &#39;`character` column. name ## # A tibble: 2 x 3 ## row col name ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 3 Matilda ## 2 2 4 Nicholas data_cells &lt;- dplyr::filter(all_cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, score = numeric) # The data is exam scores in certain subjects, so give the data that title. # The data is numeric, so select only that &#39;value&#39;. If some of the data was # also text or true/false, then you would select the `character` and `logical` # columns as well as `numeric` data_cells %&gt;% enhead(field, &quot;WNW&quot;) %&gt;% enhead(subject, &quot;W&quot;) %&gt;% enhead(name, &quot;N&quot;) %&gt;% select(-row, -col) ## # A tibble: 8 x 4 ## score field subject name ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Humanities Classics Matilda ## 2 3 Humanities Classics Nicholas ## 3 3 Humanities History Matilda ## 4 5 Humanities History Nicholas ## 5 5 Performance Music Matilda ## 6 9 Performance Music Nicholas ## 7 7 Performance Drama Matilda ## 8 12 Performance Drama Nicholas 3.2.8 Repeated rows/columns of headers within the table Repetitions can simply be ignored. Select one of the sets of headers, and use it for all the data. In this example, the data cells are easy to distinguish from the headers mixed in among them, because only the data cells have the numeric data type. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-repeated-headers&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric) %&gt;% print() ## # A tibble: 80 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 4 character Term 1 NA ## 2 2 5 character Term 2 NA ## 3 2 6 character Term 3 NA ## 4 3 2 character Classics NA ## 5 3 3 character Matilda NA ## 6 3 4 numeric &lt;NA&gt; 1 ## 7 3 5 numeric &lt;NA&gt; 8 ## 8 3 6 numeric &lt;NA&gt; 7 ## 9 4 3 character Nicholas NA ## 10 4 4 numeric &lt;NA&gt; 3 ## # ... with 70 more rows # View the cells in their original positions on the spreadsheet rectify(all_cells) ## # A tibble: 20 x 6 ## `row/col` `2(B)` `3(C)` `4(D)` `5(E)` `6(F)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 &lt;NA&gt; &lt;NA&gt; Term 1 Term 2 Term 3 ## 2 3 Classics Matilda 1 8 7 ## 3 4 &lt;NA&gt; Nicholas 3 1 2 ## 4 5 &lt;NA&gt; Olivia 4 0 1 ## 5 6 &lt;NA&gt; Paul 2 4 8 ## 6 7 &lt;NA&gt; &lt;NA&gt; Term 1 Term 2 Term 3 ## 7 8 History Matilda 4 7 3 ## 8 9 &lt;NA&gt; Nicholas 3 5 5 ## 9 10 &lt;NA&gt; Olivia 9 8 5 ## 10 11 &lt;NA&gt; Paul 6 2 0 ## 11 12 &lt;NA&gt; &lt;NA&gt; Term 1 Term 2 Term 3 ## 12 13 Music Matilda 2 9 9 ## 13 14 &lt;NA&gt; Nicholas 1 7 7 ## 14 15 &lt;NA&gt; Olivia 0 3 5 ## 15 16 &lt;NA&gt; Paul 2 2 3 ## 16 17 &lt;NA&gt; &lt;NA&gt; Term 1 Term 2 Term 3 ## 17 18 Drama Matilda 9 8 9 ## 18 19 &lt;NA&gt; Nicholas 1 3 4 ## 19 20 &lt;NA&gt; Olivia 6 1 4 ## 20 21 &lt;NA&gt; Paul 6 0 2 # The &#39;term&#39; headers appear four times, but only the first one is needed. term &lt;- dplyr::filter(all_cells, row == 2) %&gt;% select(row, col, term = character) # the title of this header is &#39;field&#39;, meaning &#39;group of subjects&#39;. # The cells are text cells (`&quot;Humanities&quot;`, `&quot;Performance&quot;`) so take the value # in the &#39;`character` column. term ## # A tibble: 3 x 3 ## row col term ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 4 Term 1 ## 2 2 5 Term 2 ## 3 2 6 Term 3 subject &lt;- dplyr::filter(all_cells, col == 2) %&gt;% select(row, col, subject = character) # The title of this header is &#39;subject&#39; # The cells are text cells (`&quot;history&quot;`, etc.) so take the value in the # &#39;`character` column. subject ## # A tibble: 4 x 3 ## row col subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 2 Classics ## 2 8 2 History ## 3 13 2 Music ## 4 18 2 Drama name &lt;- dplyr::filter(all_cells, col == 3) %&gt;% select(row, col, name = character) # The title of this header is &#39;name&#39;. # The cells are text cells, so take the value in the &#39;`character` column. name ## # A tibble: 16 x 3 ## row col name ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 3 Matilda ## 2 4 3 Nicholas ## 3 5 3 Olivia ## 4 6 3 Paul ## 5 8 3 Matilda ## 6 9 3 Nicholas ## 7 10 3 Olivia ## 8 11 3 Paul ## 9 13 3 Matilda ## 10 14 3 Nicholas ## 11 15 3 Olivia ## 12 16 3 Paul ## 13 18 3 Matilda ## 14 19 3 Nicholas ## 15 20 3 Olivia ## 16 21 3 Paul # The data cells are distinguished from the &#39;term&#39; headers by their data type -- # the data cells are numeric, whereas the term headers are character. data_cells &lt;- dplyr::filter(all_cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, score = numeric) # The data is exam scores in certain subjects, so give the data that title. # The data is numeric, so select only that &#39;value&#39;. If some of the data was # also text or true/false, then you would select the `character` and `logical` # columns as well as `numeric` data_cells ## # A tibble: 48 x 3 ## row col score ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 3 4 1 ## 2 3 5 8 ## 3 3 6 7 ## 4 4 4 3 ## 5 4 5 1 ## 6 4 6 2 ## 7 5 4 4 ## 8 5 5 0 ## 9 5 6 1 ## 10 6 4 2 ## # ... with 38 more rows data_cells %&gt;% enhead(term, &quot;N&quot;) %&gt;% enhead(subject, &quot;NNW&quot;) %&gt;% enhead(name, &quot;W&quot;) %&gt;% select(-row, -col) ## # A tibble: 48 x 4 ## score term subject name ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Term 1 Classics Matilda ## 2 8 Term 2 Classics Matilda ## 3 7 Term 3 Classics Matilda ## 4 3 Term 1 Classics Nicholas ## 5 1 Term 2 Classics Nicholas ## 6 2 Term 3 Classics Nicholas ## 7 4 Term 1 Classics Olivia ## 8 0 Term 2 Classics Olivia ## 9 1 Term 3 Classics Olivia ## 10 2 Term 1 Classics Paul ## # ... with 38 more rows 3.2.9 Headers amongst the data This happens when what is actually a row-header, instead of being presented to the left of the data, is presented above the data. (Alternatively, what is actually a column header, instead of being presented above the data, is presented to the side.) The way to handle it is to pretend that it is a row header, and use the &quot;WNW&quot; direction as normal. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;pivot-header-within-data&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric, local_format_id) %&gt;% print() ## # A tibble: 80 x 6 ## row col data_type character numeric local_format_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2 3 character Classics NA 2 ## 2 3 3 character Term 1 NA 20 ## 3 3 4 character Term 2 NA 37 ## 4 3 5 character Term 3 NA 21 ## 5 4 2 character Matilda NA 18 ## 6 4 3 numeric &lt;NA&gt; 4 18 ## 7 4 4 numeric &lt;NA&gt; 0 27 ## 8 4 5 numeric &lt;NA&gt; 7 19 ## 9 5 2 character Nicholas NA 20 ## 10 5 3 numeric &lt;NA&gt; 4 20 ## # ... with 70 more rows # View the cells in their original positions on the spreadsheet rectify(all_cells) ## # A tibble: 24 x 5 ## `row/col` `2(B)` `3(C)` `4(D)` `5(E)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 &lt;NA&gt; Classics &lt;NA&gt; &lt;NA&gt; ## 2 3 &lt;NA&gt; Term 1 Term 2 Term 3 ## 3 4 Matilda 4 0 7 ## 4 5 Nicholas 4 6 2 ## 5 6 Olivia 9 9 9 ## 6 7 Paul 5 0 0 ## 7 8 &lt;NA&gt; History &lt;NA&gt; &lt;NA&gt; ## 8 9 &lt;NA&gt; Term 1 Term 2 Term 3 ## 9 10 Matilda 0 4 2 ## 10 11 Nicholas 2 5 2 ## # ... with 14 more rows bold &lt;- which(xlsx_formats(path)$local$font$bold) # The subject headers, though mixed with the data and the &#39;term&#39; headers, are # distinguishable by the data type &quot;character&quot; and by being bold. subject &lt;- dplyr::filter(all_cells, col == 3, data_type == &quot;character&quot;, local_format_id %in% bold) %&gt;% select(row, col, subject = character) # The title of this header is &#39;subject&#39; # The cells are text cells (`&quot;history&quot;`, etc.) so take the value in the # &#39;`character` column. subject ## # A tibble: 4 x 3 ## row col subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 3 Classics ## 2 8 3 History ## 3 14 3 Music ## 4 20 3 Drama # We only need one set of the &#39;term&#39; headers term &lt;- dplyr::filter(all_cells, row == 3, data_type == &quot;character&quot;) %&gt;% select(row, col, term = character) # the title of this header is &#39;field&#39;, meaning &#39;group of subjects&#39;. # The cells are text cells (`&quot;Humanities&quot;`, `&quot;Performance&quot;`) so take the value # in the &#39;`character` column. term ## # A tibble: 3 x 3 ## row col term ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 3 Term 1 ## 2 3 4 Term 2 ## 3 3 5 Term 3 name &lt;- dplyr::filter(all_cells, col == 2) %&gt;% select(row, col, name = character) # The title of this header is &#39;name&#39;. # The cells are text cells, so take the value in the &#39;`character` column. name ## # A tibble: 16 x 3 ## row col name ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 2 Matilda ## 2 5 2 Nicholas ## 3 6 2 Olivia ## 4 7 2 Paul ## 5 10 2 Matilda ## 6 11 2 Nicholas ## 7 12 2 Olivia ## 8 13 2 Paul ## 9 16 2 Matilda ## 10 17 2 Nicholas ## 11 18 2 Olivia ## 12 19 2 Paul ## 13 22 2 Matilda ## 14 23 2 Nicholas ## 15 24 2 Olivia ## 16 25 2 Paul # The data cells are distinguished from the &#39;subject&#39; headers by their data # type -- the data cells are numeric, whereas the term headers are character. data_cells &lt;- dplyr::filter(all_cells, data_type == &quot;numeric&quot;) %&gt;% select(row, col, score = numeric) # The data is exam scores in certain subjects, so give the data that title. # The data is numeric, so select only that &#39;value&#39;. If some of the data was # also text or true/false, then you would select the `character` and `logical` # columns as well as `numeric` data_cells ## # A tibble: 48 x 3 ## row col score ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 4 3 4 ## 2 4 4 0 ## 3 4 5 7 ## 4 5 3 4 ## 5 5 4 6 ## 6 5 5 2 ## 7 6 3 9 ## 8 6 4 9 ## 9 6 5 9 ## 10 7 3 5 ## # ... with 38 more rows data_cells %&gt;% enhead(subject, &quot;WNW&quot;) %&gt;% enhead(term, &quot;N&quot;) %&gt;% enhead(name, &quot;W&quot;) %&gt;% select(-row, -col) ## # A tibble: 48 x 4 ## score subject term name ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 4 Classics Term 1 Matilda ## 2 0 Classics Term 2 Matilda ## 3 7 Classics Term 3 Matilda ## 4 4 Classics Term 1 Nicholas ## 5 6 Classics Term 2 Nicholas ## 6 2 Classics Term 3 Nicholas ## 7 9 Classics Term 1 Olivia ## 8 9 Classics Term 2 Olivia ## 9 9 Classics Term 3 Olivia ## 10 5 Classics Term 1 Paul ## # ... with 38 more rows "],
["small-multiples.html", "4 Small multiples", " 4 Small multiples You might have heard the term ‘small multiples’ in the context of graphs, but it also occurs in spreadsheets, when an array of small tables could be combined into a single table. To import an array of small tables, start by writing the code to import one, and then apply that to each in turn. Write the code to import one table. Wrap that code in a function. Partition the whole spreadsheet so that each table is in one partition. Map the function over the partitions. "],
["small-multiples-with-all-headers-present-for-each-multiple.html", "4.1 Small multiples with all headers present for each multiple", " 4.1 Small multiples with all headers present for each multiple The code to import one of these multiples will be simple. cells %&gt;% behead(&quot;NNW&quot;, subject) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col, -local_format_id) %&gt;% spatter(header) %&gt;% select(-row) The first table is in rows 1 to 4, columns 1 to 3, so we start by writing the code to import only that table. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;small-multiples&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric, local_format_id) table1 &lt;- dplyr::filter(all_cells, row %in% 1:4, col %in% 1:3) table1 %&gt;% behead(&quot;NNW&quot;, subject) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col, -local_format_id) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 2 x 4 ## subject Grade Name Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Classics F Matilda 1 ## 2 Classics D Olivia 2 We wrap that code in a function, to be applied to each separate table. unpivot &lt;- function(cells) { cells %&gt;% behead(&quot;NNW&quot;, subject) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col, -local_format_id) %&gt;% spatter(header) %&gt;% select(-row) } Now we partition the spreadsheet into the separate tables. This is done by identifying a corner cell in each table. formats &lt;- xlsx_formats(path) italic &lt;- which(formats$local$font$italic) corners &lt;- all_cells %&gt;% dplyr::filter(local_format_id %in% italic) %&gt;% select(row, col) partitions &lt;- partition(all_cells, corners) partitions ## # A tibble: 4 x 3 ## corner_row corner_col cells ## &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt; ## 1 1 1 &lt;tibble [10 × 6]&gt; ## 2 1 5 &lt;tibble [10 × 6]&gt; ## 3 6 1 &lt;tibble [10 × 6]&gt; ## 4 6 5 &lt;tibble [10 × 6]&gt; Finally, map the unpivoting function over the partitions, and combine the results. partitions %&gt;% mutate(cells = map(cells, unpivot)) %&gt;% unnest() %&gt;% select(-corner_row, -corner_col) ## # A tibble: 8 x 4 ## subject Grade Name Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Classics F Matilda 1 ## 2 Classics D Olivia 2 ## 3 History D Matilda 3 ## 4 History C Olivia 4 ## 5 Music B Matilda 5 ## 6 Music B Olivia 6 ## 7 Drama A Matilda 7 ## 8 Drama A Olivia 8 "],
["same-table-in-several-worksheetsfiles-using-the-sheetfile-name.html", "4.2 Same table in several worksheets/files (using the sheet/file name)", " 4.2 Same table in several worksheets/files (using the sheet/file name) Because tidyxl() imports cells from multiple sheets into the same data frame, tables on separate sheets can be imported by mapping over the different sheets. Just name each sheet in the xlsx_cell() call, or don’t name any to import them all. As far as tidyxl() is concerned, the particular sheet (aka ‘tab’) that a cell is on is another coordinate like row and col, so the full location of a cell is its row, its col, and its sheet. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = c(&quot;humanities&quot;, &quot;performance&quot;)) %&gt;% dplyr::filter(!is_blank) %&gt;% select(sheet, row, col, data_type, character, numeric) all_cells ## # A tibble: 16 x 6 ## sheet row col data_type character numeric ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 humanities 1 2 character Matilda NA ## 2 humanities 1 3 character Nicholas NA ## 3 humanities 2 1 character Classics NA ## 4 humanities 2 2 numeric &lt;NA&gt; 1 ## 5 humanities 2 3 numeric &lt;NA&gt; 3 ## 6 humanities 3 1 character History NA ## 7 humanities 3 2 numeric &lt;NA&gt; 3 ## 8 humanities 3 3 numeric &lt;NA&gt; 5 ## 9 performance 1 2 character Matilda NA ## 10 performance 1 3 character Nicholas NA ## 11 performance 2 1 character Music NA ## 12 performance 2 2 numeric &lt;NA&gt; 5 ## 13 performance 2 3 numeric &lt;NA&gt; 9 ## 14 performance 3 1 character Drama NA ## 15 performance 3 2 numeric &lt;NA&gt; 7 ## 16 performance 3 3 numeric &lt;NA&gt; 12 To prepare the sheets to be mapped over, use tidyr::nest(). The data column contains the cells of each sheet. all_cells %&gt;% nest(-sheet) ## # A tibble: 2 x 2 ## sheet data ## &lt;chr&gt; &lt;list&gt; ## 1 humanities &lt;tibble [8 × 5]&gt; ## 2 performance &lt;tibble [8 × 5]&gt; The function to unpivot each table in this case will be a couple of behead() statements. Further clean-up can be saved until the end. unpivot &lt;- function(cells) { cells %&gt;% behead(&quot;N&quot;, name) %&gt;% behead(&quot;W&quot;, subject) } After mapping the unpivot function over each sheet of cells, use tidyr::unnest() to show every row of data again. all_cells %&gt;% nest(-sheet) %&gt;% mutate(data = map(data, unpivot)) %&gt;% unnest() ## # A tibble: 8 x 8 ## sheet row col data_type character numeric name subject ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 humanities 2 2 numeric &lt;NA&gt; 1 Matilda Classics ## 2 humanities 2 3 numeric &lt;NA&gt; 3 Nicholas Classics ## 3 humanities 3 2 numeric &lt;NA&gt; 3 Matilda History ## 4 humanities 3 3 numeric &lt;NA&gt; 5 Nicholas History ## 5 performance 2 2 numeric &lt;NA&gt; 5 Matilda Music ## 6 performance 2 3 numeric &lt;NA&gt; 9 Nicholas Music ## 7 performance 3 2 numeric &lt;NA&gt; 7 Matilda Drama ## 8 performance 3 3 numeric &lt;NA&gt; 12 Nicholas Drama Finally, do the clean-up operations that were saved until now. all_cells %&gt;% nest(-sheet) %&gt;% mutate(data = map(data, unpivot)) %&gt;% unnest() %&gt;% transmute(field = sheet, name, subject, score = numeric) ## # A tibble: 8 x 4 ## field name subject score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 humanities Matilda Classics 1 ## 2 humanities Nicholas Classics 3 ## 3 humanities Matilda History 3 ## 4 humanities Nicholas History 5 ## 5 performance Matilda Music 5 ## 6 performance Nicholas Music 9 ## 7 performance Matilda Drama 7 ## 8 performance Nicholas Drama 12 "],
["same-table-in-several-worksheetsfiles-but-in-different-positions.html", "4.3 Same table in several worksheets/files but in different positions", " 4.3 Same table in several worksheets/files but in different positions This is almost the same as the section “Same table in several worksheets/files (using the sheet/file name)”. The only difference is that the function you write to unpivot the table must also find the table in the first place, and be robust to differences in the placement and context of the table on each sheet. In this example, both tables begin in the same column, but there is an extra row of notes above one of the tables. There are a few ways to tackle this problem. Here, we filter for the Subject cell, which is either A3 or A4, and then extend the selection to include the whole table. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = c(&quot;female&quot;, &quot;male&quot;)) %&gt;% dplyr::filter(!is_blank) %&gt;% select(sheet, row, col, data_type, character, numeric) all_cells ## # A tibble: 21 x 6 ## sheet row col data_type character numeric ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 female 1 1 character Table of scores NA ## 2 female 3 1 character Subject NA ## 3 female 3 2 character Matilda NA ## 4 female 3 3 character Olivia NA ## 5 female 4 1 character Classics NA ## 6 female 4 2 numeric &lt;NA&gt; 1 ## 7 female 4 3 numeric &lt;NA&gt; 2 ## 8 female 5 1 character History NA ## 9 female 5 2 numeric &lt;NA&gt; 3 ## 10 female 5 3 numeric &lt;NA&gt; 4 ## # ... with 11 more rows unpivot &lt;- function(cells) { cells %&gt;% dplyr::filter(character == &quot;Subject&quot;) %&gt;% pull(row) %&gt;% {dplyr::filter(cells, row &gt;= .)} %&gt;% behead(&quot;N&quot;, name) %&gt;% behead(&quot;W&quot;, subject) } all_cells %&gt;% nest(-sheet) %&gt;% mutate(data = map(data, unpivot)) %&gt;% unnest() %&gt;% select(sex = sheet, name, subject, score = numeric) ## # A tibble: 8 x 4 ## sex name subject score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 female Matilda Classics 1 ## 2 female Olivia Classics 2 ## 3 female Matilda History 3 ## 4 female Olivia History 4 ## 5 male Nicholas Classics 3 ## 6 male Paul Classics 0 ## 7 male Nicholas History 5 ## 8 male Paul History 1 "],
["implied-multiples.html", "4.4 Implied multiples", " 4.4 Implied multiples Implied multiples look like a single table, but many of the headers appear more than once. There is a dominant set of headers that are on the same ‘level’ (e.g. in the same row) as the other headers. See a real-life case study In the example, the header “Grade” is repeated, but it really belongs in each case to the header “Classics”, “History”, “Music” or “Drama”. Those subject headers serve two purposes: as title of each small multiple, and as the unstated “Score” header of their columns. The difficulty is in associating a grade with its corresponding score. Filter for the “Classics”, “History”, “Music” and “Drama” headers, and assign them to a variable to be enhead()ed later. You could think of this as faking a set of headers that doesn’t exist, but is implied. Meanwhile, behead() the original “Classics”, “History” (etc.) cells and then overwrite them with “Score”. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) all_cells &lt;- xlsx_cells(path, sheets = &quot;implied-multiples&quot;) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, character, numeric) Filter for the “Classics”, “History”, “Music” and “Drama” headers, and assign them to a variable to be enhead()ed later. subjects &lt;- all_cells %&gt;% dplyr::filter(col &gt;= 2, row == 2, character != &quot;Grade&quot;) %&gt;% select(row, col, subject = character) subjects ## # A tibble: 4 x 3 ## row col subject ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 2 Classics ## 2 2 4 History ## 3 2 6 Music ## 4 2 8 Drama Meanwhile, behead() the original “Classics”, “History” (etc.) cells and then overwrite them with “Score”. all_cells %&gt;% behead(&quot;NNW&quot;, &quot;field&quot;) %&gt;% behead(&quot;N&quot;, &quot;header&quot;) %&gt;% behead(&quot;W&quot;, &quot;name&quot;) %&gt;% enhead(subjects, &quot;NNW&quot;) %&gt;% # Reattach the filtered subject headers mutate(header = if_else(header == &quot;Grade&quot;, header, &quot;Score&quot;)) %&gt;% select(-col) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 8 x 5 ## field name subject Grade Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Humanities Matilda Classics F 1 ## 2 Humanities Matilda History D 3 ## 3 Performance Matilda Drama A 7 ## 4 Performance Matilda Music B 5 ## 5 Humanities Olivia Classics D 2 ## 6 Humanities Olivia History C 4 ## 7 Performance Olivia Drama A 8 ## 8 Performance Olivia Music B 6 "],
["formatting.html", "5 Formatting", " 5 Formatting This part explains in detail how to extract and interpret cell and in-cell formatting. Earlier sections have used formatting, but haven’t explained exactly how it works. The motivating example is a particularly pernicious gotcha: superscript symbols. The formatting of a cell is available via a lookup table. Well, not a lookup table – a lookup list-of-lists-(of-lists-)of-vectors. It seems complicated, but in fact it is straightforward to find out a cell’s formatting. Obtain the vector of formats that you need. Look up the cell’s style_format or local_format_id in that vector. "],
["an-example-formatting-lookup.html", "5.1 An example formatting lookup", " 5.1 An example formatting lookup This example shows how to look up whether a cell is bold. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) cells &lt;- xlsx_cells(path, sheet = &quot;formatting&quot;) %&gt;% select(row, col, character, style_format, local_format_id) cells ## # A tibble: 14 x 5 ## row col character style_format local_format_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 1 bold Normal 6 ## 2 2 1 italic Normal 8 ## 3 3 1 underline Normal 51 ## 4 4 1 strikethrough Normal 52 ## 5 5 1 red text Normal 12 ## 6 6 1 font size 14 Normal 53 ## 7 7 1 font arial Normal 54 ## 8 8 1 yellow fill Normal 11 ## 9 9 1 black border Normal 43 ## 10 10 1 thick border Normal 55 ## 11 11 1 dashed border Normal 56 ## 12 12 1 row height 30 Normal 1 ## 13 13 2 column width 16.76 Normal 1 ## 14 14 1 Bad&#39; style Explanatory Text 57 formats &lt;- xlsx_formats(path) bold &lt;- formats$local$font$bold # The list of lists of lists of vectors bold ## [1] FALSE TRUE TRUE FALSE FALSE TRUE TRUE FALSE FALSE FALSE FALSE ## [12] FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [45] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [56] FALSE FALSE FALSE TRUE mutate(cells, bold = bold[local_format_id]) ## # A tibble: 14 x 6 ## row col character style_format local_format_id bold ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; ## 1 1 1 bold Normal 6 TRUE ## 2 2 1 italic Normal 8 FALSE ## 3 3 1 underline Normal 51 FALSE ## 4 4 1 strikethrough Normal 52 FALSE ## 5 5 1 red text Normal 12 FALSE ## 6 6 1 font size 14 Normal 53 FALSE ## 7 7 1 font arial Normal 54 FALSE ## 8 8 1 yellow fill Normal 11 FALSE ## 9 9 1 black border Normal 43 FALSE ## 10 10 1 thick border Normal 55 FALSE ## 11 11 1 dashed border Normal 56 FALSE ## 12 12 1 row height 30 Normal 1 FALSE ## 13 13 2 column width 16.76 Normal 1 FALSE ## 14 14 1 Bad&#39; style Explanatory Text 57 FALSE A quick way to see what formatting definitions exist is to use str(). (Scroll past this for now – you don’t need to memorise it). formats &lt;- xlsx_formats(path) str(formats) ## List of 2 ## $ local:List of 6 ## ..$ numFmt : chr [1:59] &quot;General&quot; &quot;General&quot; &quot;General&quot; &quot;General&quot; ... ## ..$ font :List of 10 ## .. ..$ bold : logi [1:59] FALSE TRUE TRUE FALSE FALSE TRUE ... ## .. ..$ italic : logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. ..$ underline: chr [1:59] NA NA NA NA ... ## .. ..$ strike : logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. ..$ vertAlign: chr [1:59] NA NA NA NA ... ## .. ..$ size : num [1:59] 11 11 11 11 11 11 11 11 11 11 ... ## .. ..$ color :List of 4 ## .. .. ..$ rgb : chr [1:59] &quot;FF000000&quot; &quot;FF000000&quot; &quot;FF000000&quot; &quot;FF000000&quot; ... ## .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ name : chr [1:59] &quot;Calibri&quot; &quot;Calibri&quot; &quot;Calibri&quot; &quot;Calibri&quot; ... ## .. ..$ family : int [1:59] 2 2 2 2 2 2 2 2 2 2 ... ## .. ..$ scheme : chr [1:59] NA NA NA NA ... ## ..$ fill :List of 2 ## .. ..$ patternFill :List of 3 ## .. .. ..$ fgColor :List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ bgColor :List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ patternType: chr [1:59] NA NA NA NA ... ## .. ..$ gradientFill:List of 8 ## .. .. ..$ type : chr [1:59] NA NA NA NA ... ## .. .. ..$ degree: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ left : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ right : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ top : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ bottom: num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ stop1 :List of 2 ## .. .. .. ..$ position: num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ color :List of 4 ## .. .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. ..$ stop2 :List of 2 ## .. .. .. ..$ position: num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ color :List of 4 ## .. .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## ..$ border :List of 12 ## .. ..$ diagonalDown: logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. ..$ diagonalUp : logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. ..$ outline : logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. ..$ left :List of 2 ## .. .. ..$ style: chr [1:59] NA &quot;thin&quot; NA NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA &quot;FF000000&quot; NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ right :List of 2 ## .. .. ..$ style: chr [1:59] NA &quot;thin&quot; NA NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA &quot;FF000000&quot; NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ start :List of 2 ## .. .. ..$ style: chr [1:59] NA NA NA NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ end :List of 2 ## .. .. ..$ style: chr [1:59] NA NA NA NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ top :List of 2 ## .. .. ..$ style: chr [1:59] NA &quot;thin&quot; NA NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA &quot;FF000000&quot; NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ bottom :List of 2 ## .. .. ..$ style: chr [1:59] NA NA &quot;thin&quot; NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA NA &quot;FF000000&quot; NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ diagonal :List of 2 ## .. .. ..$ style: chr [1:59] NA NA NA NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ vertical :List of 2 ## .. .. ..$ style: chr [1:59] NA NA NA NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. ..$ horizontal :List of 2 ## .. .. ..$ style: chr [1:59] NA NA NA NA ... ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ theme : chr [1:59] NA NA NA NA ... ## .. .. .. ..$ indexed: int [1:59] NA NA NA NA NA NA NA NA NA NA ... ## .. .. .. ..$ tint : num [1:59] NA NA NA NA NA NA NA NA NA NA ... ## ..$ alignment :List of 8 ## .. ..$ horizontal : chr [1:59] &quot;general&quot; &quot;center&quot; &quot;general&quot; &quot;general&quot; ... ## .. ..$ vertical : chr [1:59] &quot;bottom&quot; &quot;bottom&quot; &quot;bottom&quot; &quot;bottom&quot; ... ## .. ..$ wrapText : logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. ..$ readingOrder : chr [1:59] &quot;context&quot; &quot;context&quot; &quot;context&quot; &quot;context&quot; ... ## .. ..$ indent : int [1:59] 0 0 0 0 0 0 0 0 0 0 ... ## .. ..$ justifyLastLine: logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. ..$ shrinkToFit : logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## .. ..$ textRotation : int [1:59] 0 0 0 0 0 0 0 0 0 0 ... ## ..$ protection:List of 2 ## .. ..$ locked: logi [1:59] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. ..$ hidden: logi [1:59] FALSE FALSE FALSE FALSE FALSE FALSE ... ## $ style:List of 6 ## ..$ numFmt : Named chr [1:2] &quot;General&quot; &quot;General&quot; ## .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## ..$ font :List of 10 ## .. ..$ bold : Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ italic : Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ underline: Named chr [1:2] NA NA ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ strike : Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ vertAlign: Named chr [1:2] NA NA ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ size : Named num [1:2] 11 11 ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ color :List of 4 ## .. .. ..$ rgb : Named chr [1:2] &quot;FF000000&quot; &quot;FF9C0006&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ name : Named chr [1:2] &quot;Calibri&quot; &quot;Calibri&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ family : Named int [1:2] 2 2 ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ scheme : Named chr [1:2] NA NA ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## ..$ fill :List of 2 ## .. ..$ patternFill :List of 3 ## .. .. ..$ fgColor :List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA &quot;FFFFC7CE&quot; ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ bgColor :List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA &quot;FFCCCCFF&quot; ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ patternType: Named chr [1:2] NA &quot;solid&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ gradientFill:List of 8 ## .. .. ..$ type : Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ degree: Named int [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ left : Named num [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ right : Named num [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ top : Named num [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ bottom: Named num [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ stop1 :List of 2 ## .. .. .. ..$ position: Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ color :List of 4 ## .. .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ stop2 :List of 2 ## .. .. .. ..$ position: Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ color :List of 4 ## .. .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## ..$ border :List of 12 ## .. ..$ diagonalDown: Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ diagonalUp : Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ outline : Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ left :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ right :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ start :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ end :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ top :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ bottom :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ diagonal :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ vertical :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ horizontal :List of 2 ## .. .. ..$ style: Named chr [1:2] NA NA ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. ..$ color:List of 4 ## .. .. .. ..$ rgb : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ theme : Named chr [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ indexed: Named int [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. .. .. ..$ tint : Named num [1:2] NA NA ## .. .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## ..$ alignment :List of 8 ## .. ..$ horizontal : Named chr [1:2] &quot;general&quot; &quot;general&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ vertical : Named chr [1:2] &quot;bottom&quot; &quot;bottom&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ wrapText : Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ readingOrder : Named chr [1:2] &quot;context&quot; &quot;context&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ indent : Named int [1:2] 0 0 ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ justifyLastLine: Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ shrinkToFit : Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ textRotation : Named int [1:2] 0 0 ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## ..$ protection:List of 2 ## .. ..$ locked: Named logi [1:2] TRUE TRUE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; ## .. ..$ hidden: Named logi [1:2] FALSE FALSE ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Normal&quot; &quot;Explanatory Text&quot; Why is this so complicated? For one thing, there are too many types of formatting available to include in the data frame given by xlsx_cells(). Consider borders: each cell can have a border on each of its four sides, as well as through the middle of the cell horizontally, vertically, diagonally up and diagonally down. Each border can have its own colour and linetype. Colour can be expressed as an RGB value, a theme number with or without a tint, or an index number. To express that in a data frame would take (4 sides + 4 through the middle) * (4 ways to express colour + 1 linetype) = 40 columns. Just for borders. Instead, Excel dynamically defines combinations of formatting, as they occur, and gives ID numbers to those combinations. Each cell has a formatting ID, which is used to look up its particular combination of formats. Note that this means two cells that are both bold can have different formatting IDs, e.g. if one is also italic. There is also a hierarchy of formatting. The first formatting to be applied is the ‘style’. Every cell has a style, which by default is the ‘normal’ style. You can reformat all cells of the ‘normal’ style at once by updating the ‘normal’ style. Style formats are available under xlsx_formats()$style When you modify the format of a particular cell, then that modification is local to that cell. The cell’s local formatting is available under xlsx_formats()$local. Both $style and $local have the same structure, so it’s easy to switch from checking a cell’s style-level formatting to its local formatting. Here’s an example of looking up both the local bold formatting and the style-level bold formatting of a cell. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) cells &lt;- xlsx_cells(path, sheet = &quot;formatting&quot;) %&gt;% select(row, col, character, style_format, local_format_id) %&gt;% dplyr::filter(row == 1, col == 1) cells ## # A tibble: 1 x 5 ## row col character style_format local_format_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 1 bold Normal 6 formats &lt;- xlsx_formats(path) local_bold &lt;- formats$local$font$bold local_bold ## [1] FALSE TRUE TRUE FALSE FALSE TRUE TRUE FALSE FALSE FALSE FALSE ## [12] FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [45] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [56] FALSE FALSE FALSE TRUE style_bold &lt;- formats$style$font$bold style_bold ## Normal Explanatory Text ## FALSE FALSE mutate(cells, style_bold = style_bold[style_format], local_bold = local_bold[local_format_id]) ## # A tibble: 1 x 7 ## row col character style_format local_format_id style_bold local_bold ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 1 1 bold Normal 6 FALSE TRUE Most of the time you will use the local formatting. You only need to check the style formatting when styles have been used in the spreadsheet (rare) and you want to ignore any local modifications of that style for particular cells. Conditional formatting is an obvious omission. It isn’t supported by tidyxl because it doesn’t encode any new information; it’s responds to cell values, which you already have. If you think you need it, feel free to open an issue. "],
["common-formats.html", "5.2 Common formats", " 5.2 Common formats This example shows how to look up the most common formats. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) cells &lt;- xlsx_cells(path, sheet = &quot;formatting&quot;) %&gt;% select(row, col, character, style_format, local_format_id, height, width) formats &lt;- xlsx_formats(path) bold &lt;- formats$local$font$bold italic &lt;- formats$local$font$italic underline &lt;- formats$local$font$underline strikethrough &lt;- formats$local$font$strike font_colour &lt;- formats$local$font$color$rgb fill_colour &lt;- formats$local$fill$patternFill$fgColor$rgb font_size &lt;- formats$local$font$size font_name &lt;- formats$local$font$name border_colour &lt;- formats$local$border$right$color$rgb border_linetype &lt;- formats$local$border$right$style mutate(cells, bold = bold[local_format_id], italic = italic[local_format_id], underline = underline[local_format_id], strikethrough = strikethrough[local_format_id], font_colour = font_colour[local_format_id], font_size = font_size[local_format_id], font_name = font_name[local_format_id], fill_colour = fill_colour[local_format_id], border_colour = border_colour[local_format_id], border_linetype = border_linetype[local_format_id]) ## # A tibble: 14 x 17 ## row col character style_format local_format_id height width bold ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 1 1 bold Normal 6 15 8.71 TRUE ## 2 2 1 italic Normal 8 15 8.71 FALSE ## 3 3 1 underline Normal 51 15 8.71 FALSE ## 4 4 1 strikethro… Normal 52 15 8.71 FALSE ## 5 5 1 red text Normal 12 15 8.71 FALSE ## 6 6 1 font size … Normal 53 18.8 8.71 FALSE ## 7 7 1 font arial Normal 54 15 8.71 FALSE ## 8 8 1 yellow fill Normal 11 15 8.71 FALSE ## 9 9 1 black bord… Normal 43 15 8.71 FALSE ## 10 10 1 thick bord… Normal 55 15 8.71 FALSE ## 11 11 1 dashed bor… Normal 56 15 8.71 FALSE ## 12 12 1 row height… Normal 1 30 8.71 FALSE ## 13 13 2 column wid… Normal 1 15 17.4 FALSE ## 14 14 1 Bad&#39; style Explanatory… 57 15 8.71 FALSE ## # ... with 9 more variables: italic &lt;lgl&gt;, underline &lt;chr&gt;, ## # strikethrough &lt;lgl&gt;, font_colour &lt;chr&gt;, font_size &lt;dbl&gt;, ## # font_name &lt;chr&gt;, fill_colour &lt;chr&gt;, border_colour &lt;chr&gt;, ## # border_linetype &lt;chr&gt; "],
["in-cell-formatting.html", "5.3 In-cell formatting", " 5.3 In-cell formatting The previous section was about formatting applied at the level of cells. What about when multiple formats are applied within a single cell? A single word in a string might be a different colour, to stand out. Unlike cell-level formatting, in-cell formatting is very limited, so it can be provided as a data frame with the following columns. bold italic underline strike vertAlign size color_rgb color_theme color_indexed color_tint font family scheme There is one of these data frames for each cell, and they are kept in a list-column called character_formatted. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) xlsx_cells(path, sheet = &quot;in-cell formatting&quot;) %&gt;% select(address, character_formatted) ## # A tibble: 9 x 2 ## address character_formatted ## &lt;chr&gt; &lt;list&gt; ## 1 A1 &lt;tibble [9 × 14]&gt; ## 2 A3 &lt;tibble [1 × 14]&gt; ## 3 B3 &lt;tibble [1 × 14]&gt; ## 4 A4 &lt;tibble [1 × 14]&gt; ## 5 B4 &lt;NULL&gt; ## 6 A5 &lt;tibble [2 × 14]&gt; ## 7 B5 &lt;NULL&gt; ## 8 A6 &lt;tibble [1 × 14]&gt; ## 9 B6 &lt;NULL&gt; The way to access these data frames is via tidyr::unnest(). In this example, a single cell has a long string of words, where each word is formatted differently. xlsx_cells(path, sheet = &quot;in-cell formatting&quot;) %&gt;% dplyr::filter(address == &quot;A1&quot;) %&gt;% select(address, character_formatted) %&gt;% unnest() ## # A tibble: 9 x 15 ## address character bold italic underline strike vertAlign size ## &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 A1 in-cell: FALSE FALSE &lt;NA&gt; FALSE &lt;NA&gt; 0 ## 2 A1 bold, TRUE FALSE &lt;NA&gt; FALSE &lt;NA&gt; 0 ## 3 A1 italic, FALSE TRUE &lt;NA&gt; FALSE &lt;NA&gt; 0 ## 4 A1 underline, FALSE FALSE single FALSE &lt;NA&gt; 0 ## 5 A1 strikethrough, FALSE FALSE &lt;NA&gt; TRUE &lt;NA&gt; 0 ## 6 A1 superscript, FALSE FALSE &lt;NA&gt; FALSE superscript 0 ## 7 A1 red, FALSE FALSE &lt;NA&gt; FALSE &lt;NA&gt; 0 ## 8 A1 arial, FALSE FALSE &lt;NA&gt; FALSE &lt;NA&gt; 0 ## 9 A1 size 14 FALSE FALSE &lt;NA&gt; FALSE &lt;NA&gt; 0 ## # ... with 7 more variables: color_rgb &lt;chr&gt;, color_theme &lt;int&gt;, ## # color_indexed &lt;int&gt;, color_tint &lt;dbl&gt;, font &lt;chr&gt;, family &lt;int&gt;, ## # scheme &lt;chr&gt; It’s hard to think of a plausible example, so what follows is an implausible one that nevertheless occurred in real life. "],
["multiple-pieces-of-information-in-a-single-cell-with-meaningful-formatting.html", "5.4 Multiple pieces of information in a single cell, with meaningful formatting", " 5.4 Multiple pieces of information in a single cell, with meaningful formatting The following table of products and their production readiness combines three pieces of information in a single cell. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) xlsx_cells(path, sheet = &quot;in-cell formatting&quot;) %&gt;% dplyr::filter(address != &quot;A1&quot;) %&gt;% rectify() ## # A tibble: 4 x 3 ## `row/col` `1(A)` `2(B)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 3 ID Count ## 2 4 A1-TEST 1 ## 3 5 A2-PRODUCTION 2 ## 4 6 A3-PRODUCTION 3 In the ID column, the first section &quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot; is the product ID. The second section &quot;TEST&quot;, &quot;PRODUCTION&quot; is the production readiness, and the formatting of &quot;TEST&quot; and &quot;PRODUCTION&quot; shows whether or not manufacturing failed. In the file, one of those strings is formatted red with a strikethrough, indicating failure. One way to extract the formatting is by unnesting, as above, but in this case we can get away with mapping over the nested data frames and pulling out a single value. strikethrough &lt;- xlsx_cells(path, sheet = &quot;in-cell formatting&quot;) %&gt;% dplyr::filter(address != &quot;A1&quot;, col == 1) %&gt;% mutate(strikethrough = map_lgl(character_formatted, ~ any(.x$strike))) %&gt;% select(row, col, character, strikethrough) This can then be joined onto the rest of the table, in the same way as the section “Already a tidy table but with meaningful formatting of single cells”. cells &lt;- xlsx_cells(path, sheet = &quot;in-cell formatting&quot;) %&gt;% dplyr::filter(address != &quot;A1&quot;) %&gt;% select(row, col, data_type, character, numeric) strikethrough &lt;- xlsx_cells(path, sheet = &quot;in-cell formatting&quot;) %&gt;% dplyr::filter(address != &quot;A1&quot;, col == 1) %&gt;% mutate(strikethrough = map_lgl(character_formatted, ~ any(.x$strike))) %&gt;% select(row, strikethrough) left_join(cells, strikethrough, by = &quot;row&quot;) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) %&gt;% select(ID, strikethrough, Count) ## # A tibble: 3 x 3 ## ID strikethrough Count ## &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; ## 1 A1-TEST NA 1 ## 2 A2-PRODUCTION TRUE 2 ## 3 A3-PRODUCTION NA 3 "],
["superscript-symbols.html", "5.5 Superscript symbols", " 5.5 Superscript symbols This is pernicious. What was Paula’s score, in the table below? path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) read_excel(path, sheet = &quot;superscript symbols&quot;) ## # A tibble: 2 x 2 ## Name Score ## &lt;chr&gt; &lt;chr&gt; ## 1 Paula 91 ## 2 Matilda 10 The answer is, it’s not Paula, it’s Paul (superscript ‘a’), who scored 9 (superscript ‘1’). This sort of thing is difficult to spot. There’s a clue in the ‘Score’ column, which has been coerced to character so that the author could enter the superscript ‘1’ (Excel doesn’t allow superscripts in numeric cells), But it would be easy to interpret that as an accident of translation, and simply coerce back to numeric with as.integer(). With tidyxl, you can count the rows of each element of the character_formatted column to identify cells that have in-cell formatting. xlsx_cells(path, sheet = &quot;superscript symbols&quot;) %&gt;% dplyr::filter(data_type == &quot;character&quot;) %&gt;% dplyr::filter(map_int(character_formatted, nrow) != 1) %&gt;% select(row, col, character) ## # A tibble: 2 x 3 ## row col character ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 1 Paula ## 2 2 2 91 The values and symbols can then be separated by assuming the value is the first string, and the symbol is the second. xlsx_cells(path, sheet = &quot;superscript symbols&quot;) %&gt;% mutate(character = map_chr(character_formatted, ~ ifelse(is.null(.x), character, .x$character[1])), symbol = map_chr(character_formatted, ~ ifelse(is.null(.x), NA, .x$character[2])), numeric = if_else(row &gt; 1 &amp; col == 2 &amp; data_type == &quot;character&quot;, as.numeric(character), numeric), character = if_else(is.na(numeric), character, NA_character_)) %&gt;% select(row, col, numeric, character, symbol) ## Warning in if_else(row &gt; 1 &amp; col == 2 &amp; data_type == &quot;character&quot;, ## as.numeric(character), : NAs introduced by coercion ## # A tibble: 6 x 5 ## row col numeric character symbol ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 1 NA Name &lt;NA&gt; ## 2 1 2 NA Score &lt;NA&gt; ## 3 2 1 NA Paul a ## 4 2 2 9 &lt;NA&gt; 1 ## 5 3 1 NA Matilda &lt;NA&gt; ## 6 3 2 10 &lt;NA&gt; &lt;NA&gt; "],
["data-validation.html", "6 Data validation", " 6 Data validation TODO: rework the vignette? "],
["formulas.html", "7 Formulas", " 7 Formulas TODO: rework the vignette? "],
["other-gotchas.html", "8 Other gotchas", " 8 Other gotchas This part is a collection of gotchas that don’t fit anywhere else. "],
["non-text-headers-e-g-dates.html", "8.1 Non-text headers e.g. dates", " 8.1 Non-text headers e.g. dates At the time of writing, readxl doesn’t convert Excel dates to R dates when they are in the header row. Using tidyxl and unpivotr, you can choose to make a cell of any data type into a tidy ‘header’, and you can reformat it as text before spatter() turns it into the header of a data frame. Another way to format headers as part of the behead() will be shown later. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) xlsx_cells(path, sheet = &quot;non-text headers&quot;) %&gt;% behead(&quot;W&quot;, name) %&gt;% behead(&quot;N&quot;, `academic-year`) %&gt;% mutate(`academic-year` = strftime(`academic-year`, &quot;%Y&quot;)) %&gt;% select(row, data_type, `academic-year`, name, numeric) %&gt;% spatter(`academic-year`) %&gt;% select(-row) ## # A tibble: 2 x 3 ## name `2017` `2018` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Matilda 4 2 ## 2 Nicholas 3 1 When a single set of headers is of mixed data types, e.g. some character and some date, behead() chooses the correct ones using the data_type column, before converting them all to text via format(). xlsx_cells(path, sheet = &quot;non-text headers&quot;) %&gt;% select(row, col, data_type, character, numeric, date) %&gt;% behead(&quot;N&quot;, header) ## # A tibble: 6 x 7 ## row col data_type character numeric date header ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; ## 1 2 1 character Matilda NA NA Name ## 2 2 2 numeric &lt;NA&gt; 2 NA 2018-01-01 ## 3 2 3 numeric &lt;NA&gt; 4 NA 2017-01-01 ## 4 3 1 character Nicholas NA NA Name ## 5 3 2 numeric &lt;NA&gt; 1 NA 2018-01-01 ## 6 3 3 numeric &lt;NA&gt; 3 NA 2017-01-01 To format a header when a single set of headers are of mixed data types, you can specify a function for each data type in the call to behead(). xlsx_cells(path, sheet = &quot;non-text headers&quot;) %&gt;% select(row, col, data_type, character, numeric, date) %&gt;% behead(&quot;N&quot;, header, formatters = list(date = ~ strftime(.x, &quot;%Y&quot;), character = toupper)) ## # A tibble: 6 x 7 ## row col data_type character numeric date header ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; ## 1 2 1 character Matilda NA NA NAME ## 2 2 2 numeric &lt;NA&gt; 2 NA 2018 ## 3 2 3 numeric &lt;NA&gt; 4 NA 2017 ## 4 3 1 character Nicholas NA NA NAME ## 5 3 2 numeric &lt;NA&gt; 1 NA 2018 ## 6 3 3 numeric &lt;NA&gt; 3 NA 2017 "],
["data-embedded-in-comments.html", "8.2 Data embedded in comments", " 8.2 Data embedded in comments Comment strings are availabe in the comment column, just like character. Comments can have formatting, but tidyxl doesn’t yet import the formatting. If you need this, please open an issue. It would probably be imported into a comment_formatted column, similarly to character_formatted. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) xlsx_cells(path, sheet = &quot;comments&quot;) %&gt;% select(row, col, data_type, character, numeric, comment) %&gt;% behead(&quot;N&quot;, &quot;header&quot;) ## # A tibble: 4 x 7 ## row col data_type character numeric comment header ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 1 character Paul NA Absent Term 1 Name ## 2 2 2 numeric &lt;NA&gt; 9 Predicted Score ## 3 3 1 character Matilda NA &lt;NA&gt; Name ## 4 3 2 numeric &lt;NA&gt; 10 &lt;NA&gt; Score Comments apply to single cells, so follow the same procedure as “Already a tidy table but with meaningful formatting of single cells”. cells &lt;- xlsx_cells(path, sheet = &quot;comments&quot;) %&gt;% select(row, col, data_type, character, numeric, comment) cells ## # A tibble: 6 x 6 ## row col data_type character numeric comment ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 1 character Name NA &lt;NA&gt; ## 2 1 2 character Score NA &lt;NA&gt; ## 3 2 1 character Paul NA Absent Term 1 ## 4 2 2 numeric &lt;NA&gt; 9 Predicted ## 5 3 1 character Matilda NA &lt;NA&gt; ## 6 3 2 numeric &lt;NA&gt; 10 &lt;NA&gt; values &lt;- cells %&gt;% select(-comment) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) values ## # A tibble: 2 x 3 ## row Name Score ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Paul 9 ## 2 3 Matilda 10 comments &lt;- cells %&gt;% behead(&quot;N&quot;, header) %&gt;% mutate(header = paste0(header, &quot;_comment&quot;)) %&gt;% select(row, header, comment) %&gt;% spread(header, comment) comments ## # A tibble: 2 x 3 ## row Name_comment Score_comment ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 Absent Term 1 Predicted ## 2 3 &lt;NA&gt; &lt;NA&gt; left_join(values, comments, by = &quot;row&quot;) %&gt;% select(-row) ## # A tibble: 2 x 4 ## Name Score Name_comment Score_comment ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Paul 9 Absent Term 1 Predicted ## 2 Matilda 10 &lt;NA&gt; &lt;NA&gt; "],
["named-ranges.html", "8.3 Named ranges", " 8.3 Named ranges TODO "],
["case-studies.html", "9 Case studies", " 9 Case studies This is a collection of spreadsheets found in the wild. Some are as easy to mung as the examples; others are harder because their structure is less consistent. Seeing and reading the code will help you guage how much work is still involved in munging a spreadsheet. Attempting them for yourself and checking the model answer will help you to hone your instincts. The spreadsheet files are provided in the smungs package on GitHub. Install as follows. # install.packages(&quot;devtools&quot;) # If you don&#39;t already have it devtools::install_github(&quot;nacnudus/smungs&quot;) "],
["australian-marriage-survey.html", "9.1 Australian Marriage Survey", " 9.1 Australian Marriage Survey These are the results of a survey in 2017 by the Australian Bureau of Statistics that asked, “Should the law be changed to allow same-sex couples to marry?” There are two tables with structures that are similar but different. Download the file. Original source. 9.1.1 The full code listing cells &lt;- xlsx_cells(smungs::ozmarriage) formats &lt;- xlsx_formats(smungs::ozmarriage) table_1 &lt;- cells %&gt;% dplyr::filter(sheet == &quot;Table 1&quot;, row &gt;= 5L, !is_blank) %&gt;% mutate(character = str_trim(character)) %&gt;% behead(&quot;NNW&quot;, &quot;population&quot;) %&gt;% behead(&quot;NNW&quot;, &quot;response&quot;) %&gt;% behead(&quot;N&quot;, &quot;unit&quot;) %&gt;% behead(&quot;W&quot;, &quot;state&quot;) %&gt;% arrange(row, col) %&gt;% select(row, data_type, numeric, state, population, response, unit) %&gt;% spatter(unit) %&gt;% select(-row) state &lt;- cells %&gt;% dplyr::filter(sheet == &quot;Table 2&quot;, row &gt;= 5L, col == 1L, !is_blank, formats$local$font$bold[local_format_id]) %&gt;% select(row, col, state = character) table_2 &lt;- cells %&gt;% dplyr::filter(sheet == &quot;Table 2&quot;, row &gt;= 5L, !is_blank) %&gt;% mutate(character = str_trim(character)) %&gt;% behead(&quot;NNW&quot;, &quot;population&quot;) %&gt;% behead(&quot;NNW&quot;, &quot;response&quot;) %&gt;% behead(&quot;N&quot;, &quot;unit&quot;) %&gt;% behead(&quot;W&quot;, &quot;territory&quot;) %&gt;% enhead(state, &quot;NNW&quot;) %&gt;% arrange(row, col) %&gt;% select(row, data_type, numeric, state, territory, population, response, unit) %&gt;% spatter(unit) %&gt;% select(-row) all_tables &lt;- bind_rows(&quot;Table 1&quot; = table_1, &quot;Table 2&quot; = table_2, .id = &quot;sheet&quot;) all_tables ## # A tibble: 1,176 x 7 ## sheet state population response `%` no. territory ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Table 1 New South Wales Eligible Par… Non-respo… 20.5 1.07e6 &lt;NA&gt; ## 2 Table 1 New South Wales Eligible Par… Response … 79.2 4.11e6 &lt;NA&gt; ## 3 Table 1 New South Wales Eligible Par… Response … 0.2 1.10e4 &lt;NA&gt; ## 4 Table 1 New South Wales Eligible Par… Total 100 5.19e6 &lt;NA&gt; ## 5 Table 1 New South Wales Response cle… No 42.2 1.74e6 &lt;NA&gt; ## 6 Table 1 New South Wales Response cle… Total 100 4.11e6 &lt;NA&gt; ## 7 Table 1 New South Wales Response cle… Yes 57.8 2.37e6 &lt;NA&gt; ## 8 Table 1 Victoria Eligible Par… Non-respo… 18.3 7.44e5 &lt;NA&gt; ## 9 Table 1 Victoria Eligible Par… Response … 81.4 3.31e6 &lt;NA&gt; ## 10 Table 1 Victoria Eligible Par… Response … 0.3 1.10e4 &lt;NA&gt; ## # ... with 1,166 more rows 9.1.2 Step by step 9.1.2.1 Table 1 The first rows, up to the column-headers, must be filtered out. The trailing rows below the table will be treated us row-headers, but because there is no data to join them to, they will be dropped automatically. That is handy, because otherwise we would have to know where the bottom of the table is, which is likely to change with later editions of the same data. Apart from filtering the first rows, the rest of this example is ‘textbook’. cells &lt;- xlsx_cells(smungs::ozmarriage) table_1 &lt;- cells %&gt;% dplyr::filter(sheet == &quot;Table 1&quot;, row &gt;= 5L, !is_blank) %&gt;% mutate(character = str_trim(character)) %&gt;% behead(&quot;NNW&quot;, &quot;population&quot;) %&gt;% behead(&quot;NNW&quot;, &quot;response&quot;) %&gt;% behead(&quot;N&quot;, &quot;unit&quot;) %&gt;% behead(&quot;W&quot;, &quot;state&quot;) %&gt;% arrange(row, col) %&gt;% select(row, data_type, numeric, state, population, response, unit) %&gt;% spatter(unit) %&gt;% select(-row) table_1 ## # A tibble: 63 x 5 ## state population response `%` no. ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 New South Wales Eligible Participants Non-responding 20.5 1.07e6 ## 2 New South Wales Eligible Participants Response clear 79.2 4.11e6 ## 3 New South Wales Eligible Participants Response not clear(… 0.2 1.10e4 ## 4 New South Wales Eligible Participants Total 100 5.19e6 ## 5 New South Wales Response clear No 42.2 1.74e6 ## 6 New South Wales Response clear Total 100 4.11e6 ## 7 New South Wales Response clear Yes 57.8 2.37e6 ## 8 Victoria Eligible Participants Non-responding 18.3 7.44e5 ## 9 Victoria Eligible Participants Response clear 81.4 3.31e6 ## 10 Victoria Eligible Participants Response not clear(… 0.3 1.10e4 ## # ... with 53 more rows 9.1.2.2 Table 2 This is like Table 1, broken down by division rather than by state. The snag is that the states are named in the same column as their divisions. Because the state names are formatted in bold, we can isolate them from the division names. With them out of the way, unpivot the rest of the table as normal, and then use enhead() at the end to join the state names back on. Since tables 1 and 2 are so similar structurally, they might as well be joined into one. cells &lt;- xlsx_cells(smungs::ozmarriage) formats &lt;- xlsx_formats(smungs::ozmarriage) state &lt;- cells %&gt;% dplyr::filter(sheet == &quot;Table 2&quot;, row &gt;= 5L, col == 1L, !is_blank, formats$local$font$bold[local_format_id]) %&gt;% select(row, col, state = character) table_2 &lt;- cells %&gt;% dplyr::filter(sheet == &quot;Table 2&quot;, row &gt;= 5L, !is_blank) %&gt;% mutate(character = str_trim(character)) %&gt;% behead(&quot;NNW&quot;, &quot;population&quot;) %&gt;% behead(&quot;NNW&quot;, &quot;response&quot;) %&gt;% behead(&quot;N&quot;, &quot;unit&quot;) %&gt;% behead(&quot;W&quot;, &quot;territory&quot;) %&gt;% enhead(state, &quot;NNW&quot;) %&gt;% arrange(row, col) %&gt;% select(row, data_type, numeric, state, territory, population, response, unit) %&gt;% spatter(unit) %&gt;% select(-row) all_tables &lt;- bind_rows(&quot;Table 1&quot; = table_1, &quot;Table 2&quot; = table_2, .id = &quot;sheet&quot;) %&gt;% select(sheet, state, territory, population, response, `%`, no.) all_tables ## # A tibble: 1,176 x 7 ## sheet state territory population response `%` no. ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Table 1 New South Wales &lt;NA&gt; Eligible Par… Non-respo… 20.5 1.07e6 ## 2 Table 1 New South Wales &lt;NA&gt; Eligible Par… Response … 79.2 4.11e6 ## 3 Table 1 New South Wales &lt;NA&gt; Eligible Par… Response … 0.2 1.10e4 ## 4 Table 1 New South Wales &lt;NA&gt; Eligible Par… Total 100 5.19e6 ## 5 Table 1 New South Wales &lt;NA&gt; Response cle… No 42.2 1.74e6 ## 6 Table 1 New South Wales &lt;NA&gt; Response cle… Total 100 4.11e6 ## 7 Table 1 New South Wales &lt;NA&gt; Response cle… Yes 57.8 2.37e6 ## 8 Table 1 Victoria &lt;NA&gt; Eligible Par… Non-respo… 18.3 7.44e5 ## 9 Table 1 Victoria &lt;NA&gt; Eligible Par… Response … 81.4 3.31e6 ## 10 Table 1 Victoria &lt;NA&gt; Eligible Par… Response … 0.3 1.10e4 ## # ... with 1,166 more rows "],
["vaccinations.html", "9.2 Vaccinations", " 9.2 Vaccinations This is a real-life example of implied multiples. Implied multiples look like a single table, but many of the headers appear more than once. There is a dominant set of headers that are on the same ‘level’ (e.g. in the same row) as the other headers. In this case, there is a small multiple for each year of data. The year headers are highlighted in yellow in the screenshot. The way to unpivot this is to realise that the year cells represent two different things: the year (obviously) and a statistic (percentage vaccinated). It would have been easier to unpivot if the years had been put into a separate row of headers, so we will pretend that that was in fact the case. Filter for the year cells and store in a variable to enhead() later. behead() everything else as usual, and then overwite the year headers with percentage_vaccinated. enhead() the year cells. The original spreadsheet has been replaced by an annual refresh, so you will need to use the file from the smungs package. cells &lt;- xlsx_cells(smungs::vaccinations, &quot;SVV Coverage Trend Data&quot;) years &lt;- cells %&gt;% dplyr::filter(row == 3, col &gt;= 1, str_detect(character, &quot;20[0-9]{2}-[0-9]{2}&quot;)) %&gt;% select(row, col, year = character) years ## # A tibble: 42 x 3 ## row col year ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 2 2009-10 ## 2 3 8 2010-11 ## 3 3 14 2011-12 ## 4 3 20 2012-13 ## 5 3 26 2013-14 ## 6 3 32 2014-15 ## 7 3 38 2015-16 ## 8 3 44 2009-10 ## 9 3 50 2010-11 ## 10 3 56 2011-12 ## # ... with 32 more rows cells %&gt;% select(row, col, data_type, character) %&gt;% behead(&quot;NNW&quot;, &quot;series&quot;) %&gt;% behead(&quot;NNW&quot;, &quot;population&quot;) %&gt;% behead(&quot;W&quot;, &quot;state&quot;) %&gt;% behead(&quot;N&quot;, &quot;header&quot;) %&gt;% mutate(header = if_else(str_detect(header, &quot;20[0-9]{2}-[0-9]{2}&quot;), &quot;percent_vaccinated&quot;, header), header = str_replace_all(str_to_lower(header), &quot; &quot;, &quot;_&quot;)) %&gt;% enhead(years, &quot;NNW&quot;) %&gt;% select(row, series, population, state, year, header, character) %&gt;% spatter(header, character) %&gt;% select(series, population, state, year, percent_vaccinated, percent_surveyed, everything()) ## # A tibble: 2,226 x 11 ## series population state year percent_vaccina… percent_surveyed row ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 School … All kinde… Alab… 2009… 94.0 100.0 4 ## 2 School … All kinde… Alab… 2010… NA NA 4 ## 3 School … All kinde… Alab… 2011… 93.6 100.0 4 ## 4 School … All kinde… Alab… 2012… 92.8 100.0 4 ## 5 School … All kinde… Alab… 2013… 92.0 100.0 4 ## 6 School … All kinde… Alab… 2014… 93.5 100.0 4 ## 7 School … All kinde… Alab… 2015… 93.1 100.0 4 ## 8 School … All kinde… Alab… 2009… NReq 100.0 4 ## 9 School … All kinde… Alab… 2010… NA NA 4 ## 10 School … All kinde… Alab… 2011… NReq 100.0 4 ## # ... with 2,216 more rows, and 4 more variables: footnotes &lt;chr&gt;, ## # survey_type &lt;chr&gt;, target &lt;chr&gt;, total_kindergarten_population &lt;chr&gt; "],
["us-crime.html", "9.3 US Crime", " 9.3 US Crime These are two tables of numbers of crimes in the USA, by state and category of crime. Confusingly, they’re numbered Table 2 and Table 3. Table 1 exists but isn’t included in this case study because it is so straightforward. 9.3.1 Table 2 9.3.1.1 Simple version This is straightforward to import as long as you don’t care to organise the hierarchies of crimes and areas. For example, Conneticut is within the division New England, which itself is within the region Northeast, but if you don’t need to express those relationships in the data then you can ignore the bold formatting. The only slight snag is that the header cells in row 5 are blank. There is a header for the units “Rate per 100,000”, but no header for the units “Count” – the cells in those positions are empty. It would be a problem if the cells didn’t exist at all, because behead(&quot;N&quot;, &quot;unit&quot;) wouldn’t be able to associate data cells with missing header cells. Fortunately they do exist (because they have formatting), they are just empty or NA. To make sure they aren’t ignored, use drop_na = FALSE in behead(), and then later fill the blanks in the units column with &quot;Count&quot;. cells &lt;- xlsx_cells(smungs::us_crime_2) %&gt;% mutate(character = map_chr(character_formatted, ~ ifelse(is.null(.x), character, .x$character[1])), character = str_replace_all(character, &quot;\\n&quot;, &quot; &quot;)) cells %&gt;% dplyr::filter(row &gt;= 4L) %&gt;% select(row, col, data_type, character, numeric) %&gt;% behead(&quot;NNW&quot;, &quot;crime&quot;) %&gt;% behead(&quot;N&quot;, &quot;unit&quot;, drop_na = FALSE) %&gt;% behead(&quot;WNW&quot;, &quot;area&quot;) %&gt;% behead(&quot;W&quot;, &quot;year&quot;) %&gt;% behead(&quot;W&quot;, &quot;population&quot;) %&gt;% dplyr::filter(year != &quot;Percent change&quot;) %&gt;% mutate(unit = if_else(unit == &quot;&quot;, &quot;Count&quot;, unit)) %&gt;% select(row, data_type, numeric, unit, area, year, population, crime) %&gt;% spatter(unit) %&gt;% select(-row) ## # A tibble: 1,320 x 6 ## area year population crime Count `Rate per 100,… ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 United States Total 2015 320896618 Aggravate… 7.64e5 238. ## 2 United States Total 2015 320896618 Burglary 1.59e6 495. ## 3 United States Total 2015 320896618 Larceny-t… 5.72e6 1784. ## 4 United States Total 2015 320896618 Motor veh… 7.13e5 222. ## 5 United States Total 2015 320896618 Murder an… 1.59e4 4.9 ## 6 United States Total 2015 320896618 Property … 8.02e6 2500. ## 7 United States Total 2015 320896618 Rape (leg… 9.13e4 28.4 ## 8 United States Total 2015 320896618 Rape (rev… 1.26e5 39.3 ## 9 United States Total 2015 320896618 Robbery 3.28e5 102. ## 10 United States Total 2015 320896618 Violent c… 1.23e6 385. ## # ... with 1,310 more rows 9.3.1.2 Complex version If you do mind about grouping states within divisions within regions, and crimes within categories, then you have more work to do using enhead() rather than behead(). Select the header cells at each level of the hierarchy and store them in their own variables. For example, filter for the bold cells in row 4, which are the categories of crimes, and store them in the categories variable. Select the data cells, and use enhead() to join them to the headers. In fact the headers unit, year, population can be handled by behead(), because they aren’t hierarchichal, so only the variables category, crime, region, division and state are handled by enhead(). cells &lt;- xlsx_cells(smungs::us_crime_2) %&gt;% mutate(character = map_chr(character_formatted, ~ ifelse(is.null(.x), character, .x$character[1])), character = str_replace_all(character, &quot;\\n&quot;, &quot; &quot;)) formats &lt;- xlsx_formats(smungs::us_crime_2) categories &lt;- cells %&gt;% dplyr::filter(row == 4L, data_type == &quot;character&quot;, formats$local$font$bold[local_format_id]) %&gt;% select(row, col, category = character) categories ## # A tibble: 2 x 3 ## row col category ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 4 Violent crime ## 2 4 16 Property crime crimes &lt;- cells %&gt;% dplyr::filter(row == 4L, data_type == &quot;character&quot;) %&gt;% mutate(character = if_else(character %in% categories$category, &quot;Total&quot;, character)) %&gt;% select(row, col, crime = character) crimes ## # A tibble: 13 x 3 ## row col crime ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 4 1 Area ## 2 4 2 Year ## 3 4 3 Population ## 4 4 4 Total ## 5 4 6 Murder and nonnegligent manslaughter ## 6 4 8 Rape (revised definition) ## 7 4 10 Rape (legacy definition) ## 8 4 12 Robbery ## 9 4 14 Aggravated assault ## 10 4 16 Total ## 11 4 18 Burglary ## 12 4 20 Larceny-theft ## 13 4 22 Motor vehicle theft regions &lt;- cells %&gt;% dplyr::filter(row &gt;= 6L, col == 1L, data_type == &quot;character&quot;, formats$local$font$bold[local_format_id]) %&gt;% select(row, col, region = character) regions ## # A tibble: 5 x 3 ## row col region ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 6 1 United States Total ## 2 9 1 Northeast ## 3 45 1 Midwest ## 4 90 1 South ## 5 153 1 West divisions &lt;- cells %&gt;% dplyr::filter(row &gt;= 6L, col == 1L, data_type == &quot;character&quot;, !formats$local$font$bold[local_format_id], !str_detect(character, &quot;^ {5}&quot;)) %&gt;% select(row, col, division = character) divisions ## # A tibble: 21 x 3 ## row col division ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 12 1 New England ## 2 33 1 Middle Atlantic ## 3 48 1 East North Central ## 4 66 1 West North Central ## 5 93 1 South Atlantic ## 6 123 1 East South Central ## 7 138 1 West South Central ## 8 156 1 Mountain ## 9 183 1 Pacific ## 10 201 1 Puerto Rico ## # ... with 11 more rows states &lt;- cells %&gt;% dplyr::filter(row &gt;= 6L, col == 1L, data_type == &quot;character&quot;) %&gt;% mutate(character = if_else(str_detect(character, &quot;^ {5}&quot;), str_trim(character), &quot;Total&quot;)) %&gt;% select(row, col, state = character) states ## # A tibble: 77 x 3 ## row col state ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 6 1 Total ## 2 9 1 Total ## 3 12 1 Total ## 4 15 1 Connecticut ## 5 18 1 Maine ## 6 21 1 Massachusetts ## 7 24 1 New Hampshire ## 8 27 1 Rhode Island ## 9 30 1 Vermont ## 10 33 1 Total ## # ... with 67 more rows cells %&gt;% dplyr::filter(row &gt;= 5L, col &gt;= 2L) %&gt;% select(row, col, data_type, character, numeric) %&gt;% behead(&quot;N&quot;, &quot;unit&quot;) %&gt;% behead(&quot;W&quot;, &quot;year&quot;) %&gt;% behead(&quot;W&quot;, &quot;population&quot;) %&gt;% enhead(categories, &quot;NNW&quot;) %&gt;% enhead(crimes, &quot;NNW&quot;) %&gt;% enhead(regions, &quot;WNW&quot;) %&gt;% enhead(divisions, &quot;WNW&quot;, drop = FALSE) %&gt;% enhead(states, &quot;WNW&quot;, drop = FALSE) %&gt;% dplyr::filter(year != &quot;Percent change&quot;) %&gt;% select(value = numeric, category, crime, region, division, state, year, population) ## # A tibble: 2,640 x 8 ## value category crime region division state year population ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 42121 Violent crime Total North… New Eng… Total 2015 14710229 ## 2 286. Violent crime Total North… New Eng… Total 2015 14710229 ## 3 41598 Violent crime Total North… New Eng… Total 2016 14735525 ## 4 282. Violent crime Total North… New Eng… Total 2016 14735525 ## 5 326 Violent crime Murder an… North… New Eng… Total 2015 14710229 ## 6 2.2 Violent crime Murder an… North… New Eng… Total 2015 14710229 ## 7 292 Violent crime Murder an… North… New Eng… Total 2016 14735525 ## 8 2 Violent crime Murder an… North… New Eng… Total 2016 14735525 ## 9 4602 Violent crime Rape (rev… North… New Eng… Total 2015 14710229 ## 10 31.3 Violent crime Rape (rev… North… New Eng… Total 2015 14710229 ## # ... with 2,630 more rows 9.3.1.3 Table 3 This table is confusing to humans, let alone computers. The Population column seems to belong to a different table altogether, so that’s how we’ll treat it. Import the Population column and the state/area headers to the left. Import the crime-related column headers, and the state/area headers to the left. Join the two datasets. The statistic header ends up having blank values due to the cells being blank, so these are manually filled in. The hierarchy of crime (e.g. ‘robbery’ is within ‘violent crime’) is ignored. That would be handled in the same way as for Table 2. cells &lt;- xlsx_cells(smungs::us_crime_3) %&gt;% mutate(character = map_chr(character_formatted, ~ ifelse(is.null(.x), character, .x$character[1])), character = str_replace_all(character, &quot;\\n&quot;, &quot; &quot;)) population &lt;- cells %&gt;% dplyr::filter(row &gt;= 5L, col &lt;= 4L) %&gt;% behead(&quot;WNW&quot;, &quot;state&quot;) %&gt;% behead(&quot;WNW&quot;, &quot;area&quot;) %&gt;% behead(&quot;W&quot;, &quot;statistic&quot;, drop_na = FALSE) %&gt;% mutate(statistic = case_when(is.na(statistic) ~ &quot;Population&quot;, statistic == &quot;&quot; ~ &quot;Population&quot;, TRUE ~ str_trim(statistic))) %&gt;% dplyr::filter(data_type == &quot;numeric&quot;, !str_detect(area, regex(&quot;total&quot;, ignore_case = TRUE)), statistic != &quot;Estimated total&quot;) %&gt;% select(data_type, numeric, state, area, statistic) %&gt;% spatter(statistic) crime &lt;- cells %&gt;% dplyr::filter(row &gt;= 4, col != 5L) %&gt;% behead(&quot;WNW&quot;, &quot;state&quot;) %&gt;% behead(&quot;WNW&quot;, &quot;area&quot;) %&gt;% behead(&quot;W&quot;, &quot;statistic&quot;, formatters = list(character = str_trim)) %&gt;% behead(&quot;N&quot;, &quot;crime&quot;) %&gt;% dplyr::filter(data_type == &quot;numeric&quot;, !str_detect(area, regex(&quot;total&quot;, ignore_case = TRUE)), !is.na(statistic), statistic != &quot;&quot;) %&gt;% mutate(statistic = case_when(statistic == &quot;Area actually reporting&quot; ~ &quot;Actual&quot;, statistic == &quot;Estimated total&quot; ~ &quot;Estimated&quot;)) %&gt;% select(data_type, numeric, state, area, statistic, crime) %&gt;% spatter(statistic) left_join(population, crime) ## Joining, by = c(&quot;state&quot;, &quot;area&quot;) ## # A tibble: 1,480 x 7 ## state area `Area actually r… Population crime Actual Estimated ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ALABAMA Cities … 0.966 520422 Aggrav… 2.84e+3 2914 ## 2 ALABAMA Cities … 0.966 520422 Burgla… 4.17e+3 4275 ## 3 ALABAMA Cities … 0.966 520422 Larcen… 1.43e+4 14641 ## 4 ALABAMA Cities … 0.966 520422 Motor … 1.34e+3 1375 ## 5 ALABAMA Cities … 0.966 520422 Murder… 4.10e+1 42 ## 6 ALABAMA Cities … 0.966 520422 Popula… 9.66e-1 1 ## 7 ALABAMA Cities … 0.966 520422 Proper… 1.98e+4 20291 ## 8 ALABAMA Cities … 0.966 520422 Rape (… 1.87e+2 193 ## 9 ALABAMA Cities … 0.966 520422 Rape (… 2.63e+2 269 ## 10 ALABAMA Cities … 0.966 520422 Robbery 4.10e+2 421 ## # ... with 1,470 more rows "],
["toronto-transit-commission.html", "9.4 Toronto Transit Commission", " 9.4 Toronto Transit Commission This table shows the number of trips recorded on the Toronto Transit Commission per year, by type of ticket, person, vehicle, and weeday/weekend/holiday. Sharla Gelfand’s annotated screenshot explains the structure. 9.4.1 The full code listing cells &lt;- xlsx_cells(smungs::toronto_transit) %&gt;% dplyr::filter(!is_blank, row &gt;= 6) fare &lt;- cells %&gt;% dplyr::filter(col == 2, !str_detect(character, &quot;^ &quot;), !str_detect(character, &quot;TOTAL&quot;)) %&gt;% select(row, col, fare = character) cells %&gt;% behead(&quot;N&quot;, &quot;year&quot;, formatters = list(character = str_trim)) %&gt;% behead(&quot;WNW&quot;, &quot;context&quot;) %&gt;% behead(&quot;W&quot;, &quot;media&quot;, formatters = list(character = str_trim)) %&gt;% enhead(fare, &quot;WNW&quot;) %&gt;% dplyr::filter(!str_detect(media, &quot;TOTAL&quot;)) %&gt;% separate(year, c(&quot;year&quot;, &quot;note&quot;), sep = &quot; &quot;, fill = &quot;right&quot;) %&gt;% select(year, context, fare, media, count = numeric) ## # A tibble: 1,188 x 5 ## year context fare media count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2017 WHO ADULT TOKENS 76106 ## 2 2016 WHO ADULT TOKENS 102073 ## 3 2015 WHO ADULT TOKENS 110945 ## 4 2014 WHO ADULT TOKENS 111157 ## 5 2013 WHO ADULT TOKENS 112360 ## 6 2012 WHO ADULT TOKENS 117962 ## 7 2011 WHO ADULT TOKENS 124748 ## 8 2010 WHO ADULT TOKENS 120366 ## 9 2009 WHO ADULT TOKENS 114686 ## 10 2008 WHO ADULT TOKENS 94210 ## # ... with 1,178 more rows 9.4.2 Step by step Although the annotations point out that there are really three separate tables (WHO, WHERE and WHEN), they can be imported as one. Coiumn 2 has two levels of headers in it: the fare in bold (“ADULT”, “BUS”, etc.), and the media used to pay for it indented by a few spaces (“TOKENS”, “WEEKLY PASS”, etc.). Because behead() can’t distinguish between different levels of headers in the same column, we need to put the bold fare headers into a separate variable on their own, and enhead() them back onto the rest of the table later. Unfortunately the fare headers in the “WHEN” context arene’t bold, so rather than filter for bold headers, instead we filter for headers that aren’t indented by spaces. We also filter out any “TOTAL” headers. cells &lt;- xlsx_cells(smungs::toronto_transit) %&gt;% dplyr::filter(!is_blank, row &gt;= 6) fare &lt;- cells %&gt;% dplyr::filter(col == 2, !str_detect(character, &quot;^ &quot;), # Filter out indented headers !str_detect(character, &quot;TOTAL&quot;)) %&gt;% # Filteroout totals select(row, col, fare = character) fare ## # A tibble: 7 x 3 ## row col fare ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 7 2 ADULT ## 2 21 2 SENIOR/STUDENT ## 3 31 2 CHILDREN ## 4 43 2 BUS ## 5 46 2 RAIL ## 6 53 2 WEEKDAY ## 7 54 2 WEEKEND/HOLIDAY ttc &lt;- cells %&gt;% behead(&quot;N&quot;, &quot;year&quot;) %&gt;% behead(&quot;WNW&quot;, &quot;context&quot;) %&gt;% behead(&quot;W&quot;, &quot;media&quot;) %&gt;% enhead(fare, &quot;WNW&quot;) %&gt;% dplyr::filter(!str_detect(media, &quot;TOTAL&quot;)) %&gt;% select(year, context, fare, media, count = numeric) ttc ## # A tibble: 1,188 x 5 ## year context fare media count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2017 WHO ADULT &quot; TOKENS&quot; 76106 ## 2 2016 WHO ADULT &quot; TOKENS&quot; 102073 ## 3 &quot; 2015 *&quot; WHO ADULT &quot; TOKENS&quot; 110945 ## 4 2014 WHO ADULT &quot; TOKENS&quot; 111157 ## 5 2013 WHO ADULT &quot; TOKENS&quot; 112360 ## 6 2012 WHO ADULT &quot; TOKENS&quot; 117962 ## 7 2011 WHO ADULT &quot; TOKENS&quot; 124748 ## 8 2010 WHO ADULT &quot; TOKENS&quot; 120366 ## 9 2009 WHO ADULT &quot; TOKENS&quot; 114686 ## 10 2008 WHO ADULT &quot; TOKENS&quot; 94210 ## # ... with 1,178 more rows There’s a bit more cosmetic cleaning to do. The indentation can be trimmed from the media and the year headers, and the asterisk removed from the year 2015 *. ttc %&gt;% mutate(year = str_trim(year), media = str_trim(media)) %&gt;% separate(year, c(&quot;year&quot;, &quot;note&quot;), sep = &quot; &quot;, fill = &quot;right&quot;) %&gt;% select(-note) ## # A tibble: 1,188 x 5 ## year context fare media count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2017 WHO ADULT TOKENS 76106 ## 2 2016 WHO ADULT TOKENS 102073 ## 3 2015 WHO ADULT TOKENS 110945 ## 4 2014 WHO ADULT TOKENS 111157 ## 5 2013 WHO ADULT TOKENS 112360 ## 6 2012 WHO ADULT TOKENS 117962 ## 7 2011 WHO ADULT TOKENS 124748 ## 8 2010 WHO ADULT TOKENS 120366 ## 9 2009 WHO ADULT TOKENS 114686 ## 10 2008 WHO ADULT TOKENS 94210 ## # ... with 1,178 more rows "]
]
